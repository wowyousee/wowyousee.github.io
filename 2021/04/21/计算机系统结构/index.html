<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机系统结构 | wow,you see的个人博客</title><meta name="author" content="zhy"><meta name="copyright" content="zhy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="第一章 计算机系统结构的基本概念 计算机系统的多级层次结构 计算机系统结构、组成和实现 软、硬取舍、计算机系统于系统结构的设计方法 软件、应用、器件对系统结构————的影响 系统结构和并行性的发展及计算机系统的分类  1.1 计算机系统中的层次概念 第五级 应用语言虚拟机                （经应用程序包翻译成高级语言程序） 第四级 高级语言虚拟机            （经编译程序翻">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统结构">
<meta property="og:url" content="http://example.com/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="wow,you see的个人博客">
<meta property="og:description" content="第一章 计算机系统结构的基本概念 计算机系统的多级层次结构 计算机系统结构、组成和实现 软、硬取舍、计算机系统于系统结构的设计方法 软件、应用、器件对系统结构————的影响 系统结构和并行性的发展及计算机系统的分类  1.1 计算机系统中的层次概念 第五级 应用语言虚拟机                （经应用程序包翻译成高级语言程序） 第四级 高级语言虚拟机            （经编译程序翻">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-04-21T12:27:59.000Z">
<meta property="article:modified_time" content="2021-05-04T08:20:13.708Z">
<meta property="article:author" content="zhy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-04 16:20:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wow,you see的个人博客</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">计算机系统结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-21T12:27:59.000Z" title="Created 2021-04-21 20:27:59">2021-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-05-04T08:20:13.708Z" title="Updated 2021-05-04 16:20:13">2021-05-04</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-计算机系统结构的基本概念"><a href="#第一章-计算机系统结构的基本概念" class="headerlink" title="第一章 计算机系统结构的基本概念"></a>第一章 计算机系统结构的基本概念</h2><ul>
<li>计算机系统的多级层次结构</li>
<li>计算机系统结构、组成和实现</li>
<li>软、硬取舍、计算机系统于系统结构的设计方法</li>
<li>软件、应用、器件对系统结构————的影响</li>
<li>系统结构和并行性的发展及计算机系统的分类</li>
</ul>
<h3 id="1-1-计算机系统中的层次概念"><a href="#1-1-计算机系统中的层次概念" class="headerlink" title="1.1 计算机系统中的层次概念"></a>1.1 计算机系统中的层次概念</h3><blockquote>
<p>第五级 应用语言虚拟机                （经应用程序包<strong>翻译</strong>成高级语言程序）</p>
<p>第四级 高级语言虚拟机            （经编译程序<strong>翻译</strong>成汇编语言或其他中间语言或机器语言）</p>
<p>第三级 汇编语言虚拟机                （经汇编程序<strong>翻译</strong>成机器语言程序）</p>
<p>第二级 操作系统虚拟机            （常用机器语言程序<strong>解释</strong>作业控制语句）</p>
<p>第一级 机器语言                        （用微程序指令<strong>解释</strong>机器指令）</p>
<p>第零级 微程序机器级                （硬件直接执行）</p>
</blockquote>
<ul>
<li><p>翻译</p>
<p>先用转换程序把N+1级上的程序<strong>整个</strong>变换成N级上的<strong>等效程序</strong>，然后在再N级上实现的技术，执行过程中N+１级程序不再被访问。</p>
</li>
<li><p>解释</p>
<p>在低级机器级上用它的<strong>一串</strong>语句或指令仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级的语言程序中的每条语句或指令逐条解释来实现的技术。</p>
</li>
</ul>
<blockquote>
<p>C ++的编译 python的terminal </p>
<p>解释执行比翻译花的时间多，但存储空间占用较少。</p>
</blockquote>
<ul>
<li>多层系统结构的意义和作用</li>
</ul>
<blockquote>
<p>推动计算机系统结构的发展（有利于正确理解软件、硬件、固件在系统中的地位和作用）</p>
<p>发展了多处理机系统、分布式处理系统、计算机网络系统（每级有各自的用户、实现方法和指令集，摆脱各级功能在一台机器实现）</p>
<p>推动虚拟机、多种操作系统共行等技术</p>
</blockquote>
<h3 id="1-2-计算机系统结构、组成与实现"><a href="#1-2-计算机系统结构、组成与实现" class="headerlink" title="1.2 计算机系统结构、组成与实现"></a>1.2 计算机系统结构、组成与实现</h3><blockquote>
<p>从计算机系统的层次结构 每级都有自已的用户、实现方法、指令系统和完成的功能 从不同 级看到的计算机属性是不同的。即<strong>客观存在的属性从某种角度看是看不到的</strong>。</p>
</blockquote>
<ul>
<li><p>透明性定义</p>
<p>在计算机中，对这种本来是存在的事物或属性，但从某种解读又好像不存在的概念称为透明性。 <strong>优点</strong>：可以不用管理它简化设计    <strong>缺点</strong>：看不到而无法控制，会带来不利</p>
</li>
</ul>
<ul>
<li>计算机组成包括</li>
</ul>
<blockquote>
<p>数据通路宽度：数据总线上一次并行传送的信息位数</p>
<p>专用功能部件的设置：选用哪些专用部件 取决于所需达到的机器速度、专用部件的使用频率和经济要素</p>
<p>各种操作对功能部件的共享程度：可设置多个部件降低共享程度，提高操作并行度来提高速度，相应价格也会提高</p>
<p>功能部件的并行性：用顺序串行，还是用重叠、流水或分布式控制和处理</p>
<p>控制机构的组方式：由硬件还是微程序控制，是单处理还是多机处理或功能分布处理</p>
<p>缓冲和排队技术</p>
<p>预测技术：为优化性能，用什么原则预测未来发生的行为</p>
<p>可靠性技术：用何种冗余和容错技术来提高可靠性</p>
</blockquote>
<ul>
<li>计算机实现</li>
</ul>
<blockquote>
<p>是指计算机组成的物理实现 着眼点在<strong>器件技术</strong>、微组装技术</p>
<p>是数字电路等课程主要研究的内容</p>
</blockquote>
<ul>
<li>系统结构与组成、实现之间的关系</li>
</ul>
<blockquote>
<p>抽象层次的不同</p>
<p>即狭义的系统结构是组成的抽象 组成是实现的抽象</p>
</blockquote>
<ul>
<li><p>系列机</p>
<p>是指一个厂家生产的具有相同的指令集结构，但具有不同组成和实现的一系列不同型号的机器</p>
</li>
</ul>
<h3 id="1-3-计算机系统的软硬取舍、性能评测及定量设计"><a href="#1-3-计算机系统的软硬取舍、性能评测及定量设计" class="headerlink" title="1.3 计算机系统的软硬取舍、性能评测及定量设计"></a>1.3 计算机系统的软硬取舍、性能评测及定量设计</h3><ul>
<li><p>计算机系统设计的任务之一</p>
<blockquote>
<p>软硬功能分配，确定软硬界面</p>
</blockquote>
</li>
<li><p>软、硬件取舍的基本原则</p>
<p>性能    价格    实现难易程度</p>
<blockquote>
<p>在现有的硬件和器件条件下，系统要有高的性价比</p>
<p>在软硬功能分配时，要考虑到准备采用的组成和实现技术，使其不过多限制或不合理限制各种组成、实现技术</p>
<p>在软硬功能分配时，除了从硬件角度考虑还有从软件的角度考虑，把为编译、OS以及高级语言的设计与实现提供更多的硬件支持放在首位。</p>
</blockquote>
</li>
<li><p>计算机系统的性能评测与定量设计原理</p>
<p><code>时间</code>    <code>空间</code></p>
<blockquote>
<p>是指：数据处理、数据传输、数据容量、数据质量的综合性能。</p>
</blockquote>
<p><code>IC</code>:指令数</p>
<p><code>CPI</code>:平均每条指令的时钟周期数</p>
<p><code>f</code>:主时钟频率</p>
<script type="math/tex; mode=display">
CPU运行时间：T_{cpu}=IC*CPI*1/f</script></li>
<li><p>反映程序的运行速度通常引入的一些指标</p>
<p><code>MIPS</code>:计算机单位时间执行的指令条数</p>
<script type="math/tex; mode=display">
MIPS=\frac{IC}{T_{cpu}*10^6}=\frac{f_c}{CPI}*10^{-6}</script><blockquote>
<p>主频越高，平均每条指令的时钟周期CPI越少，其MIPS越高，在一定程度上反映了机器性能</p>
<p>MIPS很大程度上依赖指令集，很难衡量指令系统不同机器之间的性能</p>
<p>即使在同一台机器上，程序负荷不同，CPI也不同，比如　浮点运算和定点运算</p>
<p>MIPS还与机器的硬件实现有关  浮点运算在硬件上实现，MIPS低，性能高</p>
</blockquote>
<p><code>MFLOPS</code>:Million Floating Point Operations Per Second 每秒百万次浮点运算</p>
<blockquote>
<p>只能反应机器执行浮点操作性能（适合衡量向量处理机）</p>
</blockquote>
<p><code>峰值性能</code>：计算机每秒能完成的最大计算数（理论） 不能反映系统实际性能</p>
<p><code>持续性能</code>：又称实际性能 是对真实数据处理体现的性能</p>
<blockquote>
<p>算术性能平均值    以速率或执行时间评价 （如果数据变化幅度较大或者朝某一趋势变化，那么算术平均值的意义就不太大）</p>
<p>几何平均值    指n个变量值连乘积的n次方根 无法给出系统性能的真实期望 常常使用测试机和参考机之间归一化的比值</p>
<p>调和平均值</p>
<p>调和平均数&lt;=几何平均数&lt;=算术平均数</p>
<p>考虑工作负荷中各程序出现的次序，可将程序出现的执行速率加权</p>
</blockquote>
</li>
<li><p>计算机定量设计的原理</p>
<blockquote>
<p>哈夫曼压缩原理</p>
<p>Amdahl定律</p>
<p>程序访问的局部性规律</p>
</blockquote>
</li>
<li><p>哈夫曼压缩原理</p>
<p>尽可能处理加速高概率事件远比加速低概率事件对性能提高要显著</p>
<blockquote>
<p>CPU在运算中出现溢出的概率很低，设计加快不溢出时的速度</p>
<p>缩短高频指令长度减少占用主存空间</p>
</blockquote>
</li>
<li><p>Amdahl定律</p>
<blockquote>
<p>该定律将“关注经常性事件原则”进行了量化</p>
<p>用于确定对系统中<strong>性能瓶颈部件采取措施提高速度后</strong>能得到系统性能改进的程度，即系统加速比S<sub>p</sub></p>
<p>S<sub>p</sub>与两个因素有关，即性能可改进比f<sub>new</sub>和部件加速比r<sub>new</sub></p>
<p>f<sub>new</sub>是指 系统性能可改进部件占用时间与未改进时系统总执行时间的比值</p>
<p>r<sub>new</sub>是指系统性能可改进部分在改进后性能提高的比值</p>
</blockquote>
<script type="math/tex; mode=display">
性能变化= \frac{T_{old}}{T_{new}}=\frac{T_{old}}{T_{old}*(1-x\%)+\frac{x\%*T_{old}}{r_{new}}}</script></li>
<li><p>程序访问的局部性规律</p>
<blockquote>
<p>时间局部性    一个存储项被访问，可能很快再访问</p>
<p>空间局部性    存储项被访问，它的临近项可能很快被访问</p>
</blockquote>
</li>
</ul>
<h3 id="1-4-软件、应用、器件对系统结构的影响"><a href="#1-4-软件、应用、器件对系统结构的影响" class="headerlink" title="1.4 软件、应用、器件对系统结构的影响"></a>1.4 软件、应用、器件对系统结构的影响</h3><ul>
<li><p>软件移植的三种技术</p>
<p><code>统一高级语言</code>    <code>系列机 兼容机</code>    <code>模拟与仿真</code></p>
</li>
<li><p>应用对系统结构的影响</p>
<blockquote>
<p>计算机应用的发展，必将促使计算机系统结构在以下方面有新的发展和突破：支持高速并行处理、自然语言理解、知识获取、知识表示、知识利用、知识表示、知识利用、逻辑推理、智能处理。</p>
</blockquote>
</li>
<li><p>器件的发展对系统的影响</p>
</li>
</ul>
<h3 id="1-5-并行性发展及计算机系统的分类"><a href="#1-5-并行性发展及计算机系统的分类" class="headerlink" title="1.5 并行性发展及计算机系统的分类"></a>1.5 并行性发展及计算机系统的分类</h3><ul>
<li><p>并行性概念</p>
<blockquote>
<p>只要是同一时刻或者统一时间间隔内完成两种或两种以上性质相同或不同的工作，它们在时间上能相互重叠。</p>
</blockquote>
</li>
<li><p>并行性开发途径</p>
<blockquote>
<p>资源重复 是在并行性概念中引入空间因素，通过设置硬件资源来提高可靠性或性能    <strong>阵列处理机</strong></p>
<p>时间重叠 是在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地适用同一套硬件设备的各个部分，以加快硬件周转而赢得速度    <strong>流水线计算机</strong></p>
<p>资源共享 是利用软件的方法让多个用户按照一定时间顺序轮流地使用同一套资源，以提高其利用率。<strong>多机系统</strong>    <strong>分布处理系统</strong></p>
</blockquote>
</li>
<li><p>多机系统</p>
<blockquote>
<p>指多处理机系统和多计算机系统</p>
</blockquote>
<ul>
<li><p>多处理机系统</p>
<blockquote>
<p>由多台处理机组成的单一计算机系统，各处理机都可有自己的控制部件，可带自己的局部存储器，能执行各自的程序。</p>
<p>逻辑上受统一的操作系统控制，体系结构可以是共享存储器或分布式存储器</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>多计算机系统</p>
<blockquote>
<p>由多台独立的计算机组成的系统，各计算机分别在逻辑上独立的操作系统控制下运行</p>
<p>集群系统和大规模并行处理机MMP都是多计算机系统</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>多机系统的耦合度</p>
<ul>
<li>最低耦合系统：各机之间无物理连接，也无共享的联机硬件资源，只有通过某种中间存储介质进行通讯</li>
<li>松散耦合系统：多台计算机通过通道或通信线路实现互连，共享某些磁带、磁盘等外围设备，以较低频带在文件或数据集一级相互作用 。又称<strong>间接耦合系统</strong> <strong>分布式计算机网络</strong></li>
<li>紧密耦合系统：多台计算机通过总线或高速开关互连，共享主存，并有较高的传输速度，可以实现数据集一级、任务级、作业级的并行。又称直接耦合系统。</li>
</ul>
</li>
<li><p>计算机系统的分类</p>
<ul>
<li><p>用指令流和数据流的多倍性对计算机系统分类</p>
<p><code>指令流</code>：是指机器执行的指令序列</p>
<p><code>数据流</code>：是指指令流调用的数据序列，包括输入数据和中间结果</p>
<p><code>多倍性</code>：是指在系统性能瓶颈部件上处于同一执行阶段的指令或数据的最大可能数</p>
</li>
<li><p>用指令流和执行流及其多倍性来描述计算机系统总控制器的结构特征</p>
</li>
<li><p>用数据处理的并行速度来定量地描述各种计算机系统特性</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-数据表示与指令系统"><a href="#第二章-数据表示与指令系统" class="headerlink" title="第二章 数据表示与指令系统"></a>第二章 数据表示与指令系统</h2><h3 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1 数据表示"></a>2.1 数据表示</h3><h4 id="2-1-1-数据表示与数据结构"><a href="#2-1-1-数据表示与数据结构" class="headerlink" title="2.1.1 数据表示与数据结构"></a>2.1.1 数据表示与数据结构</h4><ul>
<li><p>数据表示 </p>
<blockquote>
<p>可以由机器硬件直接识别和引用的数据类型；表现在它有对这种类型的数据进行操作的指令和运算部件</p>
</blockquote>
</li>
<li><p>数据类型</p>
<blockquote>
<p>不同于数据，数据类型除了指一组值的集合外，还定义了一组操作集（可作用于这个值的集合）</p>
</blockquote>
<p>从系统结构的观点，数据类型可以分为：</p>
<ul>
<li>基本数据类型    一般包括二进制位及其位串、整数及自然数、实数（float）、字符和布尔等</li>
<li>结构数据类型    一组由互相有关的数据元素复合而成的数据类型。比如：<strong>向量和数组、字符串、堆栈、队列、记录</strong>等</li>
<li>访问指针</li>
<li>抽象数据等类型</li>
</ul>
</li>
<li><p>数据结构</p>
<blockquote>
<p>是应用中相互之间存在一种或多种特定关系的数据元素的集合。如：线性表、栈、队列、串、数组、阵列、链表、树和图等。</p>
<p>是数据结构类型的组织方式，它反映了结构数据类型中各种元素或信息单元之间的结构关系。</p>
<p>数据表示是数据结构的子集。不同的数据表示可以为数据结构的实现提供不同的支持，存在效率的差异。</p>
</blockquote>
</li>
</ul>
<h4 id="2-1-2-高级数据表示"><a href="#2-1-2-高级数据表示" class="headerlink" title="2.1.2 高级数据表示"></a>2.1.2 高级数据表示</h4><ul>
<li><p>高级数据表示主要有三种</p>
<ul>
<li>自定义数据表示    <ul>
<li>标识符数据表示</li>
<li>数据描述符</li>
</ul>
</li>
<li>向量数据表示    向量机、通用机</li>
<li>堆栈数据表示    堆栈机器</li>
</ul>
</li>
<li><p>标识符数据表示</p>
<blockquote>
<p>为缩短高级语言与机器语言的语义差距，让机器中每个数据都带类型标志位</p>
<p>标识符由编译程序建立，对高级语言程序透明</p>
</blockquote>
<p><code>优点</code></p>
<ul>
<li>简化了指令系统和程序设计     这样指令通用于多种数据类型的处理，简化了程序设计</li>
<li>简化了编译程序     编译程序只需要形成通用的操作码，缩短了编译程序，加快了编译过程</li>
<li>便于实现一致性校验     机器硬件可直接快速检测出多种程序设计错误，提供了类型安全环境</li>
<li>能由硬件自动变换数据类型     如果操作数相容但有不同长度时，硬件能自行转换后再运算。</li>
<li>支持数据库系统的实现与数据类型无关的要求，使程序不用修改就可处理多种不同数据类型的数据</li>
<li>为软件调试和应用开发环境提供了支持</li>
</ul>
</li>
<li><p>数据描述符数据表示</p>
<blockquote>
<p>为进一步减少标识符所占存储空间，对向量、数组、记录等数据，由于元素属性相同，因此就发展出数据描述符。</p>
<p><strong>描述符和数据分开</strong>，表示访问的数据是<strong>整块</strong>还是单个，地址信息等其他信息。标识符是和每个数据相连的，<strong>合存在一个存储单元中</strong></p>
</blockquote>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210422210813394.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210422210813394.png" alt="image-20210422210813394"></p>
<p><code>优点</code>：</p>
<blockquote>
<p>描述符方法实现阵列数据的索引要比用变址方法实现更方便</p>
<p>便于检查出程序中的阵列越界错误</p>
<p>数据描述符方法为向量、数组数据结构的实现提供了一定的支持，有利于并简化编译中的代码生成，可以比变址法更快的形成元素地址</p>
</blockquote>
</li>
<li><p>向量数组数据表示</p>
<blockquote>
<p>为向量、数组数据结构的实现和快速运算提供更好的硬件支持的方法是<strong>增设向量、数组数据表示</strong>。</p>
<p>向量在内存中占用连续的内存空间；在标量计算机上运行向量时，每取一个数据元素都要计算该元素的地址，而在向量机中，由于有了向量数据表示，就可以把一个向量用<strong>一个位串</strong>表示。</p>
</blockquote>
<p><code>向量指令</code>：指能够用一条指令对向量全部元素进行运算的指令。</p>
</li>
<li><p>堆栈数据表示</p>
</li>
</ul>
<h4 id="2-1-3-引入数据表示的原则"><a href="#2-1-3-引入数据表示的原则" class="headerlink" title="2.1.3 引入数据表示的原则"></a>2.1.3 引入数据表示的原则</h4><ul>
<li>基本的数据表示必须引入</li>
<li>新的数据表示的引入是否提高系统的效率或者是否减少实现时间和所需的存储空间</li>
</ul>
<h4 id="2-1-4-浮点数尾数基值的选择技术"><a href="#2-1-4-浮点数尾数基值的选择技术" class="headerlink" title="2.1.4 浮点数尾数基值的选择技术"></a>2.1.4 浮点数尾数基值的选择技术</h4><ul>
<li>浮点数的一般格式</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428145425404.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428145425404.png" alt="image-20210428145425404"></p>
<p>​    <code>p</code>:主要影响可表示数的范围大小（阶码采用二进制 可避免运算过程中因对阶造成的精度和有效数值的过多损失）    </p>
<p>​    <code>m</code>:主要影响可表示数的精度</p>
<ul>
<li><p>选择不同浮点数尾数基值的影响</p>
<p><code>r</code><sub>m</sub>: 表示浮点数尾数的基</p>
<blockquote>
<p>为了简化讨论，只研究非负阶、正规格式化的尾数所形成的浮点数。当然，研究结论对于负阶和尾数也是适用的</p>
</blockquote>
<p><code>正规格式化尾数</code>：尾数是正的</p>
<p><code>规格化的尾数</code>：是指尾数的小数位后的<strong>第一个r<sub>m</sub>进制的尾数</strong> 不为0.因为尾数为全0的数是机器零，不作为机器中可表示的数。</p>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428161844716.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428161844716.png" alt="image-20210428161844716"></p>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428160749063.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428160749063.png" alt="image-20210428160749063"></p>
</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428161027517.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428161027517.png" alt="image-20210428161027517"></p>
<ul>
<li>浮点数尾数基址的选择<ul>
<li>可表示数的范围<ul>
<li>随着r<sub>m</sub>增大可表示的范围增大</li>
<li>随着r<sub>m</sub>增大，可表示数的最小值r<sub>m</sub><sup>-1</sup>将减小</li>
</ul>
</li>
<li>可表示数的个数<ul>
<li>2<sup>p+m</sup><em>(1-r<sup>-1</sup>)</em> r<sub>m</sub>增大，可表示的数增多</li>
</ul>
</li>
<li>可表示的精度<ul>
<li>r<sub>m</sub>越大，数在数轴上的分布越稀，数的表示精度下降（表示的尾数值增加，但是阶码权值增加，精度下降）</li>
</ul>
</li>
<li>运算中的精度损失<ul>
<li>尾数右移出机器字长，使有效数字丢失，但其不同于可表示数的精度，由于尾数基值r<sub>m</sub>取大后，对阶移位的机会和次数减少，又由于表示表示的数的范围扩大，使尾数溢出需右规的机会也减少。<strong>因此r<sub>m</sub>越大，尾数右移的机越小，精度的损失就越小。</strong></li>
</ul>
</li>
<li>运算速度<ul>
<li>r<sub>m</sub>增大时，由于<strong>对阶或尾数溢出需右移</strong>及<strong>规格化需左移</strong>的次数减小，运算速度可以提高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-5-浮点数尾数的下溢处理办法"><a href="#2-1-5-浮点数尾数的下溢处理办法" class="headerlink" title="2.1.5 浮点数尾数的下溢处理办法"></a>2.1.5 浮点数尾数的下溢处理办法</h4><ul>
<li><p>问题的提出</p>
<blockquote>
<p>信息在运算过程中会因为相乘或各种右移操作超出运算器和存储器的字长不得不舍弃，从而造成精度损失。</p>
</blockquote>
</li>
<li><p>下溢处理方法</p>
<p><code>截断法</code>    <code>舍入法</code>    <code>横置1</code>    <code>查表舍入法</code></p>
</li>
<li><p>截断法</p>
</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428163955098.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428163955098.png" alt="image-20210428163955098"></p>
<p>​    <code>优点</code>：实现简单，不增加硬件，不需要处理时间</p>
<p>​    <code>缺点</code>：最大误差较大，且平均误差大（无法调节），因此很少使用</p>
<ul>
<li>舍入法</li>
</ul>
<blockquote>
<p>增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1（整数加0.5，分数加2<sup>-(m+1)</sup>）</p>
</blockquote>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428165205305.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428165205305.png" alt="image-20210428165205305"></p>
<p><code>优点</code>：实现简单，增加的硬件开销小，最大误差小，平均误差接近于零</p>
<p><code>缺点</code>：处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需从尾数最低位进位。</p>
<ul>
<li>横置1法</li>
</ul>
<blockquote>
<p>将机器运算的规定字长的最低位恒置1</p>
</blockquote>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428165707503.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428165707503.png" alt="image-20210428165707503"></p>
<p><code>优点</code>：实现简单，不需要增加硬件和处理时间，平均误差趋于0，作用于中、高速机器中，因为尾数位数比微、小型机器长。</p>
<p><code>缺点</code>：最大误差较大，超过截断法</p>
<ul>
<li>查表舍入法</li>
</ul>
<blockquote>
<p>取尾数k位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-１位，作为新的尾数ｐ位的最后k-１位</p>
</blockquote>
<p>​    <code>下溢处理表</code></p>
<blockquote>
<p>当尾数最低k-1位为全1时以截断法设置处理结果</p>
<p>其余情况采取舍入法</p>
</blockquote>
<p><code>优点</code>：ROM法速度较快，平均误差可调到0    避免再次右规操作</p>
<p><code>缺点</code>：需要硬件配合</p>
<h3 id="2-2-寻址方式"><a href="#2-2-寻址方式" class="headerlink" title="2.2 寻址方式"></a>2.2 寻址方式</h3><h4 id="2-2-1-寻址方式的三种面向"><a href="#2-2-1-寻址方式的三种面向" class="headerlink" title="2.2.1 寻址方式的三种面向"></a>2.2.1 寻址方式的三种面向</h4><blockquote>
<p>寻址方式是指指令按照什么样的方式寻找所需的操作数或信息，即寻找操作数或信息所在地的方法叫寻址方式</p>
</blockquote>
<p>​    <code>面向主存的寻址</code>         主要访问主存，少量访问寄存器</p>
<p>​    <code>面向寄存器的寻址</code>     主要访问寄存器，少量访问主存和堆栈</p>
<p>​    <code>面向堆栈的寻址</code>         主要访问堆栈，少量访问主存或寄存器</p>
<ul>
<li><p>面向堆栈的寻址</p>
<blockquote>
<p>面向堆栈的寻址 利于减轻高级语言编译的负担，不用考虑寄存器的优化分配和使用，利于支持子程序嵌套、递归调用时的参数、返回地址以及现场等的保护和恢复。</p>
</blockquote>
<p><code>优点</code>：省去许多地址字段，省程序空间，存储效率高，免去复杂的地址计算。</p>
</li>
<li><p>面向寄存器的寻址</p>
<p><code>优点</code>：不用访存，速度比面向堆栈的寻址快得多    对于向量、矩阵运算使用面向寄存器的寻址有优势</p>
</li>
<li><p>寻址方式的指明方法</p>
<p><code>基本指令格式</code> ：操作码+地址码</p>
<ul>
<li><p>操作码占用位</p>
</li>
<li><p>不占操作码，在地址码设置寻址方式字段</p>
<p><code>特点</code>：寻址灵活、操作码短，需专门的寻址方式位字段</p>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428193114511.png" class title="This is an test image">
</li>
</ul>
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428193114511.png" alt="image-20210428193114511" style="zoom: 80%;"></p>
</li>
</ul>
<h4 id="2-2-3-程序在主存中的定位技术"><a href="#2-2-3-程序在主存中的定位技术" class="headerlink" title="2.2.3 程序在主存中的定位技术"></a>2.2.3 程序在主存中的定位技术</h4><p><code>逻辑地址</code>：程序员编写程序时使用的地址</p>
<p><code>物理地址</code>：程序在主存中的实际地址</p>
<ul>
<li><p>早期——单道程序</p>
<blockquote>
<p>逻辑地址和物理地址是一致的，程序和数据存放在主存中的位置是由程序员编写程序时指定</p>
</blockquote>
</li>
<li><p>现在——多道程序</p>
<blockquote>
<p>不再使用主存的的实际地址编程，改用符号、标号名编址</p>
<p>程序中的符号命名空间-&gt;目标程序的逻辑地址空间-&gt; 主存中的物理地址空间</p>
<p>一般来讲，逻辑地址空间大于物理地址的空间；映射实际上是压缩</p>
</blockquote>
</li>
<li><p>静态再定位</p>
<p><code>定义</code>：在目标程序装入内存时，由装入程序使用软件方法把目标程序中的指令和数据的逻辑地址地址进行<strong>修改</strong>为实际的内存地址。</p>
<p>在程序的执行过程中，物理地址不再发生改变。</p>
<p><code>存在的问题</code>：由某一道程序的初始地址出错，导致其他程序被破坏；允许指令被修改，妨碍了程序的<strong>可再入性</strong>；因为指令允许被修改，一旦程序出错，就很难找到故障点，不利于诊断和程序的调试。</p>
<p><code>可再入性</code>：可再入的（reentrant）是一个形容词，用来描述一种计算机程序或调度，这种程序或调度编写用来使内存中的同一个副本可以被多个用户共享。静态再定位法装入程序时修改了程序中的地址，破坏了程序的可再入性。</p>
</li>
<li><p>动态再定位</p>
<p><code>定义</code>：设置基址寄存器和地址加法器硬件，在程序执行期间完成的，即程序的逻辑地址在装入内存时不作任何修改，程序执行中，每取出一条指令，CPU对其译码时，如果有逻辑地址，就借助于重定位机构转换成绝对地址，然后执行该指令</p>
</li>
<li><p>基址寻址</p>
<p><code>定义</code>：指令中给出一个形式地址（修改量），并给出基址寄存器号，基址寄存器内容（基准量）与形式地址相加得到操作数为有效地址</p>
<p><code>作用</code>：程序重定位；拓展有限字长指令的寻址空间</p>
<p><code>优点</code>：地址加法器形成物理地址的速度快于装入程序所形成的物理地址速度；具有程序越界保护措施。配备下界寄存器存放a，上界寄存器存放a+m。</p>
<p><code>变址寻址和基址寻址的区别</code>：前者是对向量、数组等数据块运算的支持，使得<strong>一条指令可作用于向量中的所有分量</strong>，以利于循环程序的实现；后者是对逻辑地址空间带物理地址空间变换上的支持，以利于动态再定位技术的实现。</p>
</li>
</ul>
<h4 id="2-2-4-物理主存中信息的存储分布"><a href="#2-2-4-物理主存中信息的存储分布" class="headerlink" title="2.2.4 物理主存中信息的存储分布"></a>2.2.4 物理主存中信息的存储分布</h4><blockquote>
<p>目前使用最普遍的编制单位是字节编址，是为了适应非数值计算的需要，字节编址方式能使编制单位与信息的基本单位（1字节）相一致。</p>
<p>通常主存的访问字长是一个字节的4倍以上，甚至更高。即每个编制单位所包含的信息量（1字节）与访问一次存储器所获得的信息量（通常是1个字）不同，从而产生了数据如何在存储器存放的问题。</p>
</blockquote>
<ul>
<li>信息在存储器中按任意位置存储</li>
<li>信息在存储器中按整数边界 存储</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428201939056.png" class title="This is an test image">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428201939056.png" alt="image-20210428201939056"></p>
<h3 id="2-3-指令系统的设计与优化"><a href="#2-3-指令系统的设计与优化" class="headerlink" title="2.3 指令系统的设计与优化"></a>2.3 指令系统的设计与优化</h3><h4 id="2-3-1-指令系统设计的基本原则"><a href="#2-3-1-指令系统设计的基本原则" class="headerlink" title="2.3.1 指令系统设计的基本原则"></a>2.3.1 指令系统设计的基本原则</h4><blockquote>
<p>指令系统的设计主要包括<strong>指令的功能</strong>（操作类型、具体操作内容）和<strong>指令格式的</strong>设计</p>
</blockquote>
<ol>
<li>根据应用，初拟出指令的分类和具体的指令</li>
<li>试编出用该指令系统设计的各种高级语言的编译程序</li>
<li>对各种算法编写大量测试程序进行模拟测试，看指令系统的操作码和寻址方式效能是否比较高</li>
<li><strong>将程序中高频出现的指令串复合并改成一条强功能新指令</strong>，即改用硬件方式实现；将低频度的指令的操作改成用基本的指令组成的指令串来完成，即用软件方式实现。</li>
</ol>
<ul>
<li>指令类型<ul>
<li>非特权型：主要供应用程序员使用，也可供系统程序员使用（算术逻辑运算、数据传送、浮点运算、字符串、十进制运算、控制转移及系统控制等）</li>
<li>特权型：只供系统程序员使用，用户无权使用，用户只有先经访管指令（非特权型）调用操作系统，再由操作系统来使用这些特权指令（启动I/O、停机等待、存储管理保护、控制系统状态、诊断等）</li>
</ul>
</li>
<li>编译系统要求指令集系统应具有的特征：<ul>
<li>规整性</li>
<li>对称性</li>
<li>独立性和全能性</li>
<li>正交性</li>
<li>可组合性</li>
<li>可扩充性</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-指令操作码的优化"><a href="#2-3-2-指令操作码的优化" class="headerlink" title="2.3.2 指令操作码的优化"></a>2.3.2 指令操作码的优化</h4><p><code>指令=操作码+地址码</code></p>
<p><code>优化</code>：（指令格式的优化）如何用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短</p>
<p><code>目标</code>：节省程序的存储空间 指令格式尽量规整、便于译码。</p>
<ul>
<li><p>操作码的三种编码方法</p>
<p><code>固定长度</code>    <code>Huffman编码</code>    <code>拓展编码</code></p>
<ul>
<li>固定长度：规整性好，解码简单，空间大</li>
<li>Huffman编码：空间小，规整性不好，解码复杂</li>
<li>拓展编码：折中方案</li>
</ul>
</li>
<li><p>信息源熵H（操作码长平均数）</p>
<blockquote>
<p>Huffman编码 2.20    拓展编码 2.30     固定长度 3</p>
</blockquote>
<p><code>信息冗余量</code>：$\frac{操作码的实际平均长度-H}{操作码的实际平均长度}$    实际平均码长是指用定长操作码表示</p>
</li>
<li><p>Huffman压缩</p>
<blockquote>
<p>由于哈夫曼编码中的断码不可能是长码的前缀，从而保证了解码的唯一性和实时性</p>
</blockquote>
<ol>
<li>写出每个事件出现的频度</li>
<li>找出两个频度最低的数字，相加形成新的频度 ，插入到未参与结合的频度中</li>
<li>重复2，直到出现频度为1，建立Huffman树</li>
<li>确定Huffman代码表</li>
</ol>
<p><code>主要缺点</code>：操作码长度很不规整，硬件译码困难；</p>
<p>​                    与地址码共同组成固定长度的指令比较困难；</p>
<p>​                    Huffman代码不唯一（0、1对换或者出现出现多个相同的最小频度会产生不同的合并次序）</p>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210428213349530.png" class title="Huffman树的构建">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210428213349530.png" alt="image-20210428213349530"></p>
</li>
<li><p>拓展编码法</p>
</li>
</ul>
<p><code>定义</code>：由固定长度操作码与Huffman编码法相结合形成</p>
<blockquote>
<p>限制几种码长</p>
<p>减少平均长度</p>
<p>方便译码</p>
</blockquote>
<h4 id="2-3-3-指令地址码的优化"><a href="#2-3-3-指令地址码的优化" class="headerlink" title="2.3.3 指令地址码的优化"></a>2.3.3 指令地址码的优化</h4><blockquote>
<p>为了不降低访存取指的速度，就要维持指令字按整数边界存储，但如此一来，会浪费一定的空间，只有地址可变长，才能利用这部分空白。</p>
<p>通过采用多种不同的寻址方式、地址制、地址形式和地址码长度以及多种指令字长，将它们与可变长操作码的优化相结合，可构成冗余度尽可能少的指令字。</p>
</blockquote>
<ul>
<li>地址码个数的选择<ul>
<li>程序存储容量，包括操作码和地址</li>
<li>程序执行速度，以程序执行过程中访问主存的信息量为代表</li>
</ul>
</li>
<li>缩短地址码长度的方法<ul>
<li>用间接寻址方式</li>
<li>用变址寻址方式</li>
<li>用寄存器间接寻址方式 如16个间址寄存器，用4位地址码就能表示很长的逻辑地址空间</li>
</ul>
</li>
</ul>
<h3 id="2-4-指令系统的发展和改进"><a href="#2-4-指令系统的发展和改进" class="headerlink" title="2.4 指令系统的发展和改进"></a>2.4 指令系统的发展和改进</h3><h4 id="2-4-1-CISC和RISC"><a href="#2-4-1-CISC和RISC" class="headerlink" title="2.4.1 CISC和RISC"></a>2.4.1 CISC和RISC</h4><ul>
<li><p>指令系统的优化设计</p>
<p><code>CISC</code>：复杂指令系统60年代至七十年代中期</p>
<p><code>RISC</code>：精简指令系统70年代后期至现在</p>
<p><code>VLIW</code>：80年代初期至现在</p>
</li>
<li><p>CISC</p>
</li>
</ul>
<blockquote>
<p>早期的CPU全部是CISC架构，它的设计主要目的是要用最少的机器语言指令来完成所需的计算任务。通过强化指令系统功能的方向发展改进，越来越多的复杂指令被加入到指令系统中，这样就产生了CISC体系结构</p>
</blockquote>
<ul>
<li><p>指令系统复杂的原因</p>
<ul>
<li>当高级语言取代汇编语言后，就不断增加新的复杂指令来支持高级语言的新特性</li>
<li>由于<strong>访主存的速度显著低于访CPU寄存器的速度</strong>，因此在功能相同时，不断用一条指令功能复杂的新指令取代原先需一连串指令完成的功能，将程序软件固化、硬化。</li>
<li>系列及软件要求向上兼容和向后兼容，使得指令系统不断扩大和增加，做到向前兼容；特别是采用微程序控制后，有人就开始滥用<strong>控制存储器</strong>，导致指令条数、功能、寻址方式和指令的格式越来越复杂</li>
</ul>
</li>
<li><p>RISC</p>
</li>
</ul>
<p><code>精简的方向</code>：减少指令总数和简化指令的功能，降低硬件设计的复杂性，提高指令的执行速度</p>
<p>​                        只保留功能简单的指令    </p>
<p>​                        功能复杂的指令用软件实现</p>
<p>​                        提供流水线效率</p>
<p><code>发展的制约因素</code>：串行性是RICS架构的本质特征</p>
<p>​                            基本代码快中指令级并行度十分有限</p>
<ul>
<li>CISC体系结构的特征<ul>
<li>庞大的指令集、众多的寻址方式</li>
<li>指令长度以及执行时间不同</li>
<li>微指令译码结构    在CISC体系结构的CPU中所有机器指令必须在CPU内部译码为微程序代码，微程序集存放在CPU内部的控制存储器ROM中。机器指令被读入CPU后经过译码单元，一条复杂的CISC指令被译码为多个微程序代码，然后送入CPU执行单元进行操作。因此从本质上来说，<strong>CISC体系结构的CPU译码过程是软件工作过程，它必然影响CPU的运行速度。</strong></li>
<li>软件功能硬件化</li>
</ul>
</li>
</ul>
<h4 id="按CISC方向发展和改进指令系统"><a href="#按CISC方向发展和改进指令系统" class="headerlink" title="按CISC方向发展和改进指令系统"></a>按CISC方向发展和改进指令系统</h4><ul>
<li><p>面向目标程序的优化实现来改进</p>
<blockquote>
<p>分析指令系统，确定哪些基本操作宜于用一条指令实现，哪些基本操作宜于用一串指令实现，尽可能提高目标程序效率，缩短目标程序的长度</p>
</blockquote>
</li>
<li><p>面向高级语言的优化实现来改进</p>
<blockquote>
<p>缩短高级语言和机器语言的语义差异</p>
<p>有利于支持高级语言编译系统</p>
<p>缩短编译程序长度和编译所需时间</p>
</blockquote>
</li>
<li><p>面向操作系统的优化实现来改进</p>
<blockquote>
<p>如何通过缩短操作系统与计算机机构之间的语义差异，进一步减少运行操纵系统的时间和所占的存储空间</p>
</blockquote>
</li>
</ul>
<h4 id="按RISC方向发展和改进指令系统"><a href="#按RISC方向发展和改进指令系统" class="headerlink" title="按RISC方向发展和改进指令系统"></a>按RISC方向发展和改进指令系统</h4><ul>
<li><p>RISC体系结构的特征</p>
<ul>
<li>简单的指令集</li>
<li>执行速度快</li>
<li>寄存器-寄存器操作</li>
<li>支持指令流水线</li>
<li>重视优化编译技术</li>
</ul>
</li>
<li><p>重叠寄存器窗口技术</p>
<p><code>目标</code>：缩短CALL、RETURN操作时间</p>
<p><code>方法</code>：将设置的大量的寄存器，分成多个组和全局区；每个组中分高、本地、低三个区；相邻组的高、低区重叠，加速参数与结果的传递。</p>
<p><code>结果</code>：节省了保存现场和回复现场等辅助时间</p>
</li>
<li><p>延迟转移技术</p>
</li>
<li><p>优化编译技术</p>
</li>
<li><p>RISC体系结构的缺点</p>
<ul>
<li>基于RICS体系结构的处理器增加了编译器的实现难度</li>
<li>由于指令少，原来CICS上由单一指令玩成的某些复杂功能现在需要多条RISC指令才能完成</li>
<li>对浮点运算执行和虚拟存储器的支持虽有很大加强，但仍显不足。</li>
<li>RISC机器的编译程序比CISC的难写。</li>
</ul>
</li>
</ul>
<h2 id="第三章-存储、中断、总线与输入-输出系统"><a href="#第三章-存储、中断、总线与输入-输出系统" class="headerlink" title="第三章 存储、中断、总线与输入/输出系统"></a>第三章 存储、中断、总线与输入/输出系统</h2><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503150358568.png" class title="学习目标">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503150358568.png" alt="image-20210503150358568"></p>
<h3 id="3-1-存储系统的基本要求和并行贮存系统"><a href="#3-1-存储系统的基本要求和并行贮存系统" class="headerlink" title="3.1 存储系统的基本要求和并行贮存系统"></a>3.1 存储系统的基本要求和并行贮存系统</h3><h4 id="3-1-1-存储系统的基本要求"><a href="#3-1-1-存储系统的基本要求" class="headerlink" title="3.1.1 存储系统的基本要求"></a>3.1.1 存储系统的基本要求</h4><p><code>存储器的要求</code>：大容量、高速度和低价格</p>
<ul>
<li><p>存储器的容量</p>
<p><code>W</code>：存储体的字长（位、字节）</p>
<p><code>l</code>：每个存储体的字数</p>
<p><code>M</code>：并行工作的存储体的个数</p>
<script type="math/tex; mode=display">
S_M=W*l*M</script></li>
<li><p>存储体</p>
<blockquote>
<p>存储体是存储单元的集合，用来存放数据</p>
</blockquote>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503151537308.png" class title="存储体">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503151537308.png" alt="image-20210503151537308"></p>
<p><code>地址译码驱动电路</code>：译码器和驱动器    译码器将地址总线输入的地址码转换成与之对应的译码输出线上的有效电平，以表示选中了某一存储单元，然后由驱动器提供电流去驱动对应的读写电路，完成对被选中存储单元的读写操作；</p>
<p><code>I/O和读写电路</code>：读出放大器、写入电路和读写控制电路 用以完成对被选中存储单元的读出和写入操作</p>
</li>
<li><p>存储器的存取速度（单字）</p>
<ul>
<li><p>访问时间    存储器从接到访存读申请到信息被读到数据总线上所需的时间</p>
</li>
<li><p>存储周期    一个存储体连续启动所需要的间隔时间（连续启动两次读操作所需间隔的最小时间）</p>
</li>
<li><p>最大频宽（带宽）    存储器连续访问时的频宽，一般用每秒钟传送的信息位数（或字节数）来衡量</p>
<script type="math/tex; mode=display">
单体的频宽B_m=\frac{W}{T_M}</script></li>
</ul>
</li>
</ul>
<h4 id="3-1-2-并行主存系统"><a href="#3-1-2-并行主存系统" class="headerlink" title="3.1.2 并行主存系统"></a>3.1.2 并行主存系统</h4><ul>
<li><p>单体单字存储器</p>
<ul>
<li>假设存储器字长W与CPU所要访问的字（数据或指令）的字长W相同，则CPU从主存获得信息的速度为W/T<sub>M</sub>,我们称这种主存是单体单字存储器</li>
</ul>
</li>
<li><p>单体多字存储器</p>
<ul>
<li>为了提高主存频宽B<sub>m</sub>，在相同器件条件下，<strong>提高存储器字长</strong>，使主存在一个存储周期内读出多个CPU字，相当于提高了主存频宽</li>
</ul>
<blockquote>
<p>前提是指令和数据在主存中必须是连续存放的，一旦遇到转移指令或者操作数不能连续存放，这种方法的效果就不明显。</p>
</blockquote>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503155310684.png" class title="单体多字存储器">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503155310684.png" alt="image-20210503155310684"></p>
</li>
<li><p>多体单字交叉存取存储器</p>
</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503155510810.png" class title="多体交叉存取存储器">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503155510810.png" alt="image-20210503155510810"></p>
<ul>
<li><p>多体交叉编址</p>
<blockquote>
<p>地址按并行分体横向顺序编号，地址序号连续的两个存储单元依次分布在相邻的存储分体中，而不是一个体内排序，称为<strong>多体交叉编制</strong>    如果在M个模块上交叉编址（M=2<sup>m</sup>）,则称为模M交叉编址。</p>
</blockquote>
</li>
<li><p>模m低位多体交叉编址</p>
</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503172901578.png" class title="模m低位多体交叉编址">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503172901578.png" alt="image-20210503172901578"></p>
<p>地址A＝ｍ＊ｉ＋ｊ；ｉ＝０，１，２，．．ｌ－１　　ｊ＝０，１，２，．．ｍ－１</p>
<p><code>寻址规则</code>:</p>
<blockquote>
<p>体地址 A%m</p>
<p>体内地址  A/l</p>
</blockquote>
<p><code>适用性</code>：适用于流水、向量或阵列机；适合于单处理机内的数据存取和带Cache的主存（将数据存放在不同模块内，可以降低访存冲突）</p>
<ul>
<li>模m高位交叉编址</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503173900333.png" class title="模m高位交叉编址">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503173900333.png" alt="image-20210503173900333"></p>
<p>地址A＝ｍ＊ｊ＋ｉ；ｉ＝０，１，２．．．ｍ－１；ｊ＝０，１，２．．．ｌ－１；</p>
<p><code>寻址规则</code>：</p>
<blockquote>
<p>体地址：j=A/m</p>
<p>体内地址：i=A % l</p>
</blockquote>
<p><code>适用性</code>：适合于共享存储器的多机系统，适合于指令和数据分别存放于不同分体中；在单任务系统中，采用高位交叉访问方式的主要目的是扩大存储器容量；在多任务和多用户系统中，可以通过把不同的任务分配给不同的存储体来提高存储器的访问速度。</p>
<ul>
<li><p>并行存储器系统</p>
<blockquote>
<p>能并行读取多个CPU字的单体多字、多体单字或多体多字的交叉存储主存系统；实际上是一种采用流水线方式工作的并行存储器；</p>
</blockquote>
</li>
<li><p>定量分析主存频宽与分体数m、转移概率λ的关系</p>
<ul>
<li>提高模m值，能提高主存系统的最大频宽。但主存的实际频宽并不随m值的增大而线性提高。（系统效率问题，程序不总是顺序执行；m越大，存储器数据总线越长，总线上负载越重，导致增加传输延迟增加）</li>
</ul>
</li>
</ul>
<h3 id="3-2-中断系统"><a href="#3-2-中断系统" class="headerlink" title="3.2 中断系统"></a>3.2 中断系统</h3><h4 id="3-2-1-中断的分类和分级"><a href="#3-2-1-中断的分类和分级" class="headerlink" title="3.2.1 中断的分类和分级"></a>3.2.1 中断的分类和分级</h4><p><code>中断源</code>：引起中断的各种事件</p>
<p><code>中断响应</code>：就是允许中断CPU现行程序的运行，转而去对该请求进行预处理，包括保存好断点及其现场，调出中断服务程序，准备运行。</p>
<ul>
<li><p>中断分类</p>
<ul>
<li>由外围设备引起的中断：低速外围设备；高速外围设备的前处理和后处理</li>
<li>由处理机产生的中断：算术运算溢出，除数为0，数据校验错。非法数据格式等</li>
<li>由存储器产生的中断：地址越界、地址不存在、、写ROM、页面失效、数据或地址校验错、访问主存超时等。</li>
<li>由控制器产生的中断：非法指令、未定义操作码、用户程序执行了特权指令、堆栈溢出、分时系统中时间片用户态与特权态的切换等。</li>
<li>由总线产生的中断：输入输出总线出错、存储器总线出错等</li>
<li>实时过程控制产生的中断</li>
<li>实时钟的定时中断</li>
<li>多处理机系统中，从其他处理及发送来的中断</li>
<li>硬件故障中断</li>
<li>电源故障中断</li>
</ul>
<p><code>中断分类目的</code>：对于中断源数量较多，如果为每个中断源单独形成入口地址，硬件实现难、代价大。并且相当一部分中断源性质相近，可以对他们进行分类，对每一类给定一个中断服务程序入口，再有软件分支转入相应的中断处理部分，简化了入口地址形成硬件。</p>
</li>
<li><p>中断分级</p>
<p><code>目的</code>：同一时刻常常会同时发生多个中断请求，其响应和处理仍有优先次序，根据中断的性质、紧迫性、重要以及软件处理的方便性上把他们分为几级</p>
<h4 id="3-2-2-中断的响应次序和处理次序"><a href="#3-2-2-中断的响应次序和处理次序" class="headerlink" title="3.2.2 中断的响应次序和处理次序"></a>3.2.2 中断的响应次序和处理次序</h4><blockquote>
<p>中断的响应次序是在同时发生多个不同中断类的中断请求时，中断响应硬件中的<strong>排队器</strong>所决定的响应次序</p>
</blockquote>
</li>
<li><p>动态调整响应次序</p>
</li>
</ul>
<blockquote>
<p>在中断级请求源与中断响应排队器的入口端之间又加设了一个<strong>中断级屏蔽字寄存器</strong>和相应的控制门电路硬件，中断级屏蔽字寄存器中的每一个中断级屏蔽位可以控制让相应等级的中断请求能否进入中断响应排队器中参加排队。</p>
<p>操作系统可以通过修改各中断级处理程序的中断级屏蔽位的状况，来使中断处理的次序符合我们的期望</p>
</blockquote>
<h4 id="3-2-3-中断系统的软硬件功能分配"><a href="#3-2-3-中断系统的软硬件功能分配" class="headerlink" title="3.2.3 中断系统的软硬件功能分配"></a>3.2.3 中断系统的软硬件功能分配</h4><p><code>考虑因素</code>：中断响应时间、灵活性</p>
<p><code>中断响应时间</code>：从中断源向处理机发出中断服务请求开始，到处理机开始执行这个中断源的中断服务程序时为止。</p>
<ul>
<li>中断处理过程<ul>
<li>[x] 现行指令执行结束，且没有更紧急的服务请求（硬件）</li>
<li>[x] 关CPU中断（硬件）（第一条关CPU中断采用硬件实现，因为非常容易）</li>
<li>[x] 保存中断点，PC中的内容（硬件）</li>
<li>[ ] 撤销中断请求（软硬皆可）</li>
<li>[ ] 保存硬件现场（软硬皆可）</li>
<li>[ ] 识别中断源（软硬皆可）</li>
<li>[ ] 改变设备的屏蔽状态（软硬皆可）</li>
<li>[x] 进入中断服务程序入口（硬件）</li>
<li>[ ] 保存软件现场，通用寄存器等（软硬皆可）</li>
<li>[ ] 打开CPU中断，CPU可以响应更高级别的中端请求（软件）</li>
<li>[ ] 中断服务，执行中断服务程序（<strong>软件</strong>）</li>
<li>[ ] 关CPU中断（软件）</li>
<li>[ ] 恢复软件现场（软硬皆可）</li>
<li>[ ] 恢复屏蔽状态（软硬皆可）</li>
<li>[ ] 恢复硬件现场（软硬皆可）</li>
<li>[ ] 打开CPU中断（软硬皆可）</li>
<li>[ ] 返回中断点（<strong>软件</strong>）</li>
</ul>
</li>
</ul>
<h3 id="3-3-总线系统"><a href="#3-3-总线系统" class="headerlink" title="3.3 总线系统"></a>3.3 总线系统</h3><p><code>总线（BUS）</code>：是用于互联计算机、CPU、存储器、I/O端口及外部设备、远程通信设备间<strong>信息传送通路</strong>的集合。关键特征：<strong>共享传输介质</strong>。</p>
<p><code>总线系统</code>：总线与其相配合的附属控制电路系统。</p>
<p><code>分类</code>：按信息传送功能、性能的不同，总线系统包括数据线、地址线、命令、时序和中断信号等控制/状态线、电源线、地线以及备用线等。</p>
<p><code>数据线</code>：根数决定同时传送的shujuweish</p>
<p><code>地址线</code>：根数决定直接寻址的范围</p>
<p><code>控制/状态线</code>：决定总线的功能和使用能力</p>
<p><code>备用线</code>：用于系统功能的扩充</p>
<ul>
<li>总线的信息传送方式<ul>
<li>串行传送    一条线，脉冲传送，顺序传送一个数码的所有二进制位</li>
<li>并行传送    信息字有多少位就需要多少传输线，电位传送，所有位同时传送</li>
<li>分时传送    1.总线复用方式：既传送地址也传送数据（因此需要划分时间片，在不同的时间内完成不同的任务）    2.共享总线的部件分时使用总线。</li>
</ul>
</li>
</ul>
<h4 id="3-3-1-总线的分类"><a href="#3-3-1-总线的分类" class="headerlink" title="3.3.1 总线的分类"></a>3.3.1 总线的分类</h4><ul>
<li><p>按照在系统中的位置划分</p>
<ul>
<li>芯片级（CPU内部总线） 连接各寄存器和运算部件</li>
<li>板级（系统总线）连接插件板内各个组件 如CPU、存储器、I/O接口之间的总线</li>
<li>系统级（外总线）系统间或主机与I/O接口或设备之间的总线</li>
</ul>
</li>
<li><p>按照信息传送的方向</p>
<ul>
<li>单向传输    </li>
</ul>
<p><code>单工</code>：是指发送方与接收方只有一条数据线路，而且这条数据线路永远只能及逆行一个方向的传输</p>
<ul>
<li>双向传输<ul>
<li>半双工：是指发送方与接收方也只有一条数据线路，但这条数据线路可以在不同时刻进行两个方向的传输</li>
<li>全双工：两条线路，同一时刻可以利用这两条数据线路进行不同方向的数据传输</li>
</ul>
</li>
</ul>
</li>
<li><p>按照用法分为</p>
<ul>
<li><p>专用总线    只连接一对物理部件的总线</p>
<p><code>优点</code>：多个部件可以同时通信；不争用总线，系统流量高；通信无需指明源和目的，控制简单；总线失效时不受影响，系统可靠性高。</p>
<p><code>缺点</code>：线数多，成本高；不利于模块化；总线利用率低</p>
</li>
<li><p>非专用总线    总线可以被多个部件分时共享，但同一时刻只能有一对设备使用总线</p>
<p><code>优点</code>：总线属少，造价低；总线接口标准化，模块性强；可扩充能力强；方便用多重总线来提高总线的带宽和可靠性，使故障弱化</p>
<p><code>缺点</code>：系统流量小；经常出现总线争用的情况；未获得总线使用权的部件不得不等待而降低效率</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-2-总线的控制方式"><a href="#3-3-2-总线的控制方式" class="headerlink" title="3.3.2 总线的控制方式"></a>3.3.2 总线的控制方式</h4><ul>
<li>串行链式查询</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503205502068.png" class title="串行链式查询">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503205502068.png" alt="image-20210503205502068"></p>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503204847359.png" class title="优缺点">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503204847359.png" alt="image-20210503204847359"></p>
<ul>
<li>集中式定时查询</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503205747718.png" class title="集中式定时查询">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503205747718.png" alt="image-20210503205747718"></p>
<p><code>优点</code>：因计数器初值、部件号均可由程序置定，优先次序可用程序控制，灵活性强；不会因某个部件失效而影响其他部件对总线的使用，可靠性高。</p>
<p><code>缺点</code>：控制线的线数较多，需要2+log2（N）（向上取整）；可以共享总线的部件数受限于定时查询线的线数（编址能力），扩展性差；控制较为复杂，总线分配的速度取决于计数信号的频率和部件数，不能很高。</p>
<ul>
<li>集中式独立请求方式</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210503210124711.png" class title="集中式独立请求方式} ![image-20210503210120520](E:\hexo\source\_posts\计算机系统结构\image-20210503210124711.png) &#96;优点&#96;：总线分配速度快，所有部件的总线请求同时送到总线控制器，不用查询；控制器可以使用程序可控的预定方式、自适应方式、循环方式或它们的混合方式确定使用总线的部件；可以方便隔离失效部件。 &#96;缺点&#96;：控制线数量过大，如果有N个设备，需要2N+1根控制线；总控器要复杂得多。 #### 3.3.3 总线的通信技术 &gt; 当获得总线的使用权后，还必须给出通信的”源“和”目的“部件、传送信息的类型和方向等，之后才开始传送数据 + 总线通信的方式 + 同步通信 由**同一时标**控制数据传送 + 优点：信息传送的速度高；基本上不受总线长度的影响 + 缺点：对同步信号要求高；部件间速度差异大时会严重影响系统的效率；缺少信息在通信过程中是否被正确接收的回答 + 异步通信 采用**应答方式**，没有公共时钟标准 + 异步单向源控式通信 + 优点：简单、高速 + 缺点：没有来自目的部件知名传送是否有效的回答；不同速度部件间 的通信困难，部件内设置缓冲器以缓冲来不及处理的数据；效率低、高速部件很难发挥其效能；要求”数据准备“干扰小，否则容易误认为有效信号 {%asset_img image-20210503213901419.png 异步通信">
<p>  <img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210503213901419.png" alt="image-20210503213901419"></p>
<ul>
<li><p>单向目控式通信</p>
<p><code>优点</code>：可以解决传送有效性校验的问题；如果有错误，目的部件回送”数据出错“代替下一个”数据请求“；总线传输速率随源、目的之间距离的增加而下降</p>
<p><code>缺点</code>：不能保证下一数据传送之前让所有数据线和控制线的电平信号恢复成初始状态，总而造成错误，为此可采用异步请求/回答式双向控制</p>
</li>
<li><p>双向源控非互锁</p>
</li>
</ul>
<p><code>优点</code>：提供出错控制；便于实现不同速度部件间的通讯。<br><code>缺点</code>：二次总线延迟，速度受损；增加控制逻辑的负担；如果总线传输延迟与通讯信号脉宽的比值不合适，就有可能出现在下一个“数据准备”到达目的端时，上一个“数据接收”仍处于高电平，从而造成下一个数据的接收错误。</p>
<ul>
<li>双向源控互锁（广泛使用）</li>
</ul>
<blockquote>
<p>下一个”数据准备“信号再上一个”数据接收“信号结束后再发生。</p>
</blockquote>
<h4 id="3-3-4-数据宽度与总线线数"><a href="#3-3-4-数据宽度与总线线数" class="headerlink" title="3.3.4 数据宽度与总线线数"></a>3.3.4 数据宽度与总线线数</h4><ul>
<li>数据宽度</li>
</ul>
<p><code>数据宽度</code>   指I/O设备取得I/O总线使用权后所传送的信息总量</p>
<p><code>数据通路宽度</code>   是数据传送的物理宽度，即一个时钟周期所传送的信息量</p>
<ul>
<li>数据宽度的种类<ul>
<li>单字（8位是也叫单字节）适合打印机等低速设备，但磁盘就不合适。不用指明传送信息的长度，辅助开销小</li>
<li>定长块    适合磁盘等高速设备。但是块的长度大小要合适，过小会多次进行分配总线，过大会在最后一个块传送时，过长块会束缚总线和两个设备。</li>
<li>可变长块    适合高优先级的中高速设备。灵活性好</li>
<li>单字加定长块    适合于低速而优先级高的设备</li>
<li>单字加可变长块    是<strong>传送效率最高</strong>的一种。灵活多变，但费用也高。</li>
</ul>
</li>
<li>总线的线数</li>
</ul>
<blockquote>
<p>总线需要有发送电路、接收电路、传输导线或电缆、光缆、转接插头和电源等这部分的成本呢高于逻辑电路</p>
<p>线数越多 成本越高，干扰越大，可靠性越差，占用空间越大，传送的速度和流量越大</p>
<p>总线越长 成本越高，干扰越大，可靠性越低</p>
</blockquote>
<p><code>减少总线线数的方法</code>：组合；串、并联转换；编码</p>
<h3 id="3-4-输入-输出系统"><a href="#3-4-输入-输出系统" class="headerlink" title="3.4 输入/输出系统"></a>3.4 输入/输出系统</h3><h2 id="第四章-存储体系"><a href="#第四章-存储体系" class="headerlink" title="第四章 存储体系"></a>第四章 存储体系</h2><h3 id="4-1-存储体系概念"><a href="#4-1-存储体系概念" class="headerlink" title="4.1 存储体系概念"></a>4.1 存储体系概念</h3><h4 id="4-1-1-存储体系基本概念"><a href="#4-1-1-存储体系基本概念" class="headerlink" title="4.1.1 存储体系基本概念"></a>4.1.1 存储体系基本概念</h4><p><code>存储系统</code>：为了满足大容量、高速度和低价格的目标，需要将多种不同工艺的存储器组织在一起。（主存储器、Cache、通用寄存器、先行缓冲存储器、磁盘存储器、磁带存储器、光盘存储器等）</p>
<p><code>存储体系</code>：在构成存储系统的几种不同的存储器之间，配上辅助软、硬件或辅助硬件，使之从应用程序员来看，在逻辑上是一个整体。</p>
<ul>
<li>基本的二级存储体系<ul>
<li>虚拟存储器（容量）    是因为主存容量无法满足要要求而提出。在主存和辅存之间增设辅助的软、硬件设备，让它们构成一个整体，也称为主存-辅存存储层次。（速度上是主存，容量上是辅存）</li>
<li>Cache存储器（速度）  是因为主存速度满足不了要求而提出。在CPU和主存之间增设高速、小容量、价格较高的Cache，用辅助硬件将其与主存构成整体，也称Cache存储器或Cache-主存存储层次</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-存储体系的构成依据"><a href="#4-1-2-存储体系的构成依据" class="headerlink" title="4.1.2 存储体系的构成依据"></a>4.1.2 存储体系的构成依据</h4><blockquote>
<p>为了使存储体系能有效工作，当CPU要即将用到某个地址的内容时，可以提前被调用到最快的M<sub>1</sub>中。</p>
</blockquote>
<ul>
<li><p>计算机时间上的局部性    最近的未来要用到的信息很可能也是现在正在使用的信息。</p>
</li>
<li><p>计算机空间上的局部性    最近的未来要用到的信息很可能与现在正在使用的信息在程序空间上是近邻的</p>
</li>
</ul>
<blockquote>
<p>预知的准确性是存储层次设计好坏的主要标志</p>
</blockquote>
<h4 id="4-1-3-存储体系的性能参数"><a href="#4-1-3-存储体系的性能参数" class="headerlink" title="4.1.3 存储体系的性能参数"></a>4.1.3 存储体系的性能参数</h4><p>关注的性能参数：<code>存储层次的每位价格c</code>     <code>命中率</code>    <code>存储层次的效率</code></p>
<ul>
<li><p>命中率 </p>
<ul>
<li>假设二级存储体系中</li>
</ul>
<img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210504160130194.png" class title="命中率">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210504160130194.png" alt="image-20210504160130194"></p>
<script type="math/tex; mode=display">
H=\frac{N_1}{N_1+N_2}</script></li>
</ul>
<h3 id="4-2-虚拟存储器"><a href="#4-2-虚拟存储器" class="headerlink" title="4.2 虚拟存储器"></a>4.2 虚拟存储器</h3><ul>
<li>如果处理器没有MMU，或者MMU未启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片接收，这称为<strong>物理地址PA（Physical Address）</strong>，简称PA</li>
<li>如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称之为<strong>虚拟地址（Virtual Address）</strong>，简称VA，而MMU将这个地址翻译成另一个地址发送到CPU芯片的外部地址引脚上，即将VA映射成PA</li>
</ul>
<blockquote>
<p>虚拟存储系统是在存储层次结构（）基础上，通过存储器管理部件MMU，进行虚拟地址和实际地址自动变换而实现的，对每个编程者都是透明的，编址空间很大。80386和80486MMU的组成和功能大致形同，都是采用<strong>分段分页管理</strong>方式。</p>
</blockquote>
<h4 id="4-2-1-虚拟存储管理方式"><a href="#4-2-1-虚拟存储管理方式" class="headerlink" title="4.2.1 虚拟存储管理方式"></a>4.2.1 虚拟存储管理方式</h4><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/image-20210504161927467.png" class title="虚拟存储管理方式">
<p><img src="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/hexo\source\_posts\计算机系统结构\image-20210504161927467.png" alt="image-20210504161927467"></p>
<h4 id="4-2-2-页式虚拟存储器构成"><a href="#4-2-2-页式虚拟存储器构成" class="headerlink" title="4.2.2 页式虚拟存储器构成"></a>4.2.2 页式虚拟存储器构成</h4><h4 id="4-2-3-页式虚拟存储器实现中的问题"><a href="#4-2-3-页式虚拟存储器实现中的问题" class="headerlink" title="4.2.3 页式虚拟存储器实现中的问题"></a>4.2.3 页式虚拟存储器实现中的问题</h4><h3 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h3><h3 id="4-4-Cache-主存-辅存三级层次"><a href="#4-4-Cache-主存-辅存三级层次" class="headerlink" title="4.4 Cache-主存-辅存三级层次"></a>4.4 Cache-主存-辅存三级层次</h3><h3 id="4-5-主存保护"><a href="#4-5-主存保护" class="headerlink" title="4.5 主存保护"></a>4.5 主存保护</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">http://example.com/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/25/Untitled%201/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2021/03/23/Algorithm-note/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Algorithm note</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">zhy</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算机系统结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B1%82%E6%AC%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 计算机系统中的层次概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E3%80%81%E7%BB%84%E6%88%90%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 计算机系统结构、组成与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E7%A1%AC%E5%8F%96%E8%88%8D%E3%80%81%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E5%8F%8A%E5%AE%9A%E9%87%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 计算机系统的软硬取舍、性能评测及定量设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%BD%AF%E4%BB%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E5%99%A8%E4%BB%B6%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 软件、应用、器件对系统结构的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%B9%B6%E8%A1%8C%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 并行性发展及计算机系统的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">第二章 数据表示与指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 数据表示与数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 高级数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%BC%95%E5%85%A5%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 引入数据表示的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E5%9F%BA%E5%80%BC%E7%9A%84%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4 浮点数尾数基值的选择技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E4%B8%8B%E6%BA%A2%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5 浮点数尾数的下溢处理办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9D%A2%E5%90%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 寻址方式的三种面向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E7%A8%8B%E5%BA%8F%E5%9C%A8%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.3 程序在主存中的定位技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E7%89%A9%E7%90%86%E4%B8%BB%E5%AD%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E5%88%86%E5%B8%83"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.4 物理主存中信息的存储分布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 指令系统的设计与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 指令系统设计的基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 指令操作码的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 指令地址码的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 指令系统的发展和改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-CISC%E5%92%8CRISC"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 CISC和RISC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89CISC%E6%96%B9%E5%90%91%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">按CISC方向发展和改进指令系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89RISC%E6%96%B9%E5%90%91%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">按RISC方向发展和改进指令系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E6%80%BB%E7%BA%BF%E4%B8%8E%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">第三章 存储、中断、总线与输入&#x2F;输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82%E5%92%8C%E5%B9%B6%E8%A1%8C%E8%B4%AE%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 存储系统的基本要求和并行贮存系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 存储系统的基本要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%B9%B6%E8%A1%8C%E4%B8%BB%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 并行主存系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%88%86%E7%BA%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 中断的分类和分级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%AC%A1%E5%BA%8F%E5%92%8C%E5%A4%84%E7%90%86%E6%AC%A1%E5%BA%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 中断的响应次序和处理次序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%88%86%E9%85%8D"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 中断系统的软硬件功能分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 总线系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 总线的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 总线的控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E6%80%BB%E7%BA%BF%E7%BA%BF%E6%95%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.4 数据宽度与总线线数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 输入&#x2F;输出系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 存储体系概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 存储体系基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB%E7%9A%84%E6%9E%84%E6%88%90%E4%BE%9D%E6%8D%AE"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 存储体系的构成依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB%E7%9A%84%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 存储体系的性能参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 虚拟存储管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%84%E6%88%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 页式虚拟存储器构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 页式虚拟存储器实现中的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 高速缓冲存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Cache-%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E4%B8%89%E7%BA%A7%E5%B1%82%E6%AC%A1"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Cache-主存-辅存三级层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%B8%BB%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 主存保护</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/04/25/Untitled%201/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/04/25/Untitled%201/" title="No title">No title</a><time datetime="2021-04-25T06:03:21.301Z" title="Created 2021-04-25 14:03:21">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机系统结构"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机系统结构"/></a><div class="content"><a class="title" href="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机系统结构">计算机系统结构</a><time datetime="2021-04-21T12:27:59.000Z" title="Created 2021-04-21 20:27:59">2021-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/23/Algorithm-note/" title="Algorithm note"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Algorithm note"/></a><div class="content"><a class="title" href="/2021/03/23/Algorithm-note/" title="Algorithm note">Algorithm note</a><time datetime="2021-03-23T12:41:11.000Z" title="Created 2021-03-23 20:41:11">2021-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/13/CF706/" title="CF706"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF706"/></a><div class="content"><a class="title" href="/2021/03/13/CF706/" title="CF706">CF706</a><time datetime="2021-03-13T06:02:25.000Z" title="Created 2021-03-13 14:02:25">2021-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/31/%E4%B8%80%E7%AF%87%E8%A2%AB%E6%90%81%E7%BD%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="一篇被搁置的第一篇博客"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一篇被搁置的第一篇博客"/></a><div class="content"><a class="title" href="/2021/01/31/%E4%B8%80%E7%AF%87%E8%A2%AB%E6%90%81%E7%BD%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="一篇被搁置的第一篇博客">一篇被搁置的第一篇博客</a><time datetime="2021-01-31T09:39:41.000Z" title="Created 2021-01-31 17:39:41">2021-01-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By zhy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>