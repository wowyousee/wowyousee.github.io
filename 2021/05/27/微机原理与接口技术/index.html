<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>微机原理与接口技术 | wow,you see的个人博客</title><meta name="author" content="zhy"><meta name="copyright" content="zhy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="微处理器与总线结构8088&#x2F;8086 CPU123456\begin&amp;#123;cases&amp;#125;最小模式 \\ \\\\\最大模式 \\\end&amp;#123;cases&amp;#125;  两种工作模式   \begin{cases} 最大模式 （单处理机模式，所有控制信号由微控制器产生）\\ \\\\\ 最小模式 （多处理机模式，部分信号由外部总线控制器产生）\\ \end{cases}最小模式">
<meta property="og:type" content="article">
<meta property="og:title" content="微机原理与接口技术">
<meta property="og:url" content="http://example.com/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="wow,you see的个人博客">
<meta property="og:description" content="微处理器与总线结构8088&#x2F;8086 CPU123456\begin&amp;#123;cases&amp;#125;最小模式 \\ \\\\\最大模式 \\\end&amp;#123;cases&amp;#125;  两种工作模式   \begin{cases} 最大模式 （单处理机模式，所有控制信号由微控制器产生）\\ \\\\\ 最小模式 （多处理机模式，部分信号由外部总线控制器产生）\\ \end{cases}最小模式">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-05-27T05:16:47.713Z">
<meta property="article:modified_time" content="2021-05-29T09:05:54.983Z">
<meta property="article:author" content="zhy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-29 17:05:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wow,you see的个人博客</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">微机原理与接口技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-27T05:16:47.713Z" title="Created 2021-05-27 13:16:47">2021-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-05-29T09:05:54.983Z" title="Updated 2021-05-29 17:05:54">2021-05-29</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="微处理器与总线结构"><a href="#微处理器与总线结构" class="headerlink" title="微处理器与总线结构"></a>微处理器与总线结构</h2><h3 id="8088-8086-CPU"><a href="#8088-8086-CPU" class="headerlink" title="8088/8086 CPU"></a>8088/8086 CPU</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\<span class="variable">begin</span><span class="punctuation">&#123;</span><span class="variable">cases</span><span class="punctuation">&#125;</span></span><br><span class="line">最小模式 \\ \\\\\</span><br><span class="line">最大模式 \\</span><br><span class="line">\<span class="variable">end</span><span class="punctuation">&#123;</span><span class="variable">cases</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>两种工作模式</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
最大模式 （单处理机模式，所有控制信号由微控制器产生）\\ \\\\\
最小模式 （多处理机模式，部分信号由外部总线控制器产生）\\
\end{cases}</script><p><code>最小模式</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527133811623.png" alt></p>
<p><code>最大模式</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527140247438.png" alt="image-20210527140247438"></p>
<h4 id="8088主要引脚信号"><a href="#8088主要引脚信号" class="headerlink" title="8088主要引脚信号"></a>8088主要引脚信号</h4><script type="math/tex; mode=display">
主要有四组
\begin{cases}
完成一次访问内存或接口所需要的主要信号 \\ \\
与外部同步控制信号 \\\\
中断请求和响应信号\\\\
总线保持和响应信号\\
\end{cases}</script><ul>
<li>完成一次访问内存或接口所需要的主要信号</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
完成一次访问内存或接口所需要的主要信号
\end{cases}</script><p><code>微处理器读取一条指令的过程</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527142609456.png" alt="image-20210527142609456"></p>
<ul>
<li><p>地址线和数据线</p>
<blockquote>
<p>20位地址信号产生1M个编码</p>
<p>8位数据信号可同时传输8bit二进制码</p>
</blockquote>
<ul>
<li>AD<sub>0</sub>—AD<sub>7</sub>：低八位地址和低八位数据信号分时复用传送地址信号时为单向，传送数据为双向</li>
<li>A<sub>16</sub>—A<sub>19</sub>：高四位地址信号，与<strong>状态信号</strong>分时复用</li>
<li>A<sub>8</sub>—A<sub>15</sub>：八位地址信号</li>
</ul>
</li>
<li><p>主要控制信号</p>
<ul>
<li><p>$\overline{\text{WR}}$：写信号</p>
</li>
<li><p>$\overline{\text{RD}}$：读信号</p>
</li>
<li><p>IO/$\overline{\text{M}}$：为0表示访问内存，为1表示访问接口</p>
</li>
<li><p>$\overline{\text{DEN}}$：低电平有效，允许进行读写（）</p>
</li>
<li><p>DT/$\overline{\text{R}}$：数据收发器的传送方向控制</p>
</li>
<li><p>ALE：地址锁存信号</p>
</li>
<li><p>RESET：复位信号</p>
</li>
<li><p>REDAY</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527144601066.png" alt="image-20210527144601066"></p>
</li>
</ul>
</li>
<li><p>中断请求和响应信号（对于CPU外部的中断）</p>
<ul>
<li>INTR：可屏蔽中断请求输入端</li>
<li>NMI：非屏蔽中断请求输入端</li>
<li>$\overline{\text{INTA}}$：中断响应输出端（用于响应INTR）</li>
</ul>
</li>
<li><p>总线保持信号（DMA方式使用）</p>
<ul>
<li>HOLD：总线保持请求信号输入端当<strong>CPU以外的设备</strong>要求占用总线时，通过该引脚向CPU发出申请</li>
<li>HLDA：对HOLD的响应信号</li>
</ul>
</li>
</ul>
<p><code>8088与8086的区别</code></p>
<ul>
<li><p>数据总线宽度不同</p>
<ul>
<li>8088的外部总线宽度为8位，8086外部总线宽度为16位</li>
</ul>
</li>
<li><p>访问存储器和输入输出信号含义不同</p>
<p>8088IO/$\overline{\text{M}}$ 低电平访问内存</p>
<p>8086IO/M 低电平访问接口</p>
</li>
</ul>
<h3 id="8088内部结构"><a href="#8088内部结构" class="headerlink" title="8088内部结构"></a>8088内部结构</h3><p><code>示意图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527150904354.png" alt="image-20210527150904354"></p>
<ul>
<li><p>执行单元EU</p>
<ul>
<li>运算器</li>
<li>8个通用寄存器</li>
<li>1个标志寄存器</li>
<li>EU部分控制电路</li>
</ul>
<p><code>功能</code></p>
<ul>
<li>指令译码</li>
<li>指令执行</li>
<li>暂存中间运算结果</li>
<li>保存运算结果特征</li>
</ul>
</li>
<li><p>总线接口单元BIU</p>
<p><code>功能</code></p>
<ul>
<li>从内存中取指令到<strong>指令预取队列</strong></li>
<li>负责内存或I/O接口之间的数据传输</li>
<li>在执行转移程序时，BIU使指令预取队列复位，从指定的新地址取指令，并立即传送到执行单元执行</li>
</ul>
</li>
</ul>
<p><code>结论</code></p>
<blockquote>
<p>指令预取队列的存在使EU和BIU可以同时进行工作提高了CPU的效率；降低了对存储器存取速度的要求</p>
</blockquote>
<h3 id="8088内部寄存器"><a href="#8088内部寄存器" class="headerlink" title="8088内部寄存器"></a>8088内部寄存器</h3><p><code>14个16位寄存器</code></p>
<script type="math/tex; mode=display">
按功能划分
\begin{cases}
8个通用寄存器 \\\\
4个段寄存器\\\\
2个控制寄存器\\
\end{cases}</script><ul>
<li><p>通用寄存器</p>
<ul>
<li><p>数据寄存器</p>
<ul>
<li>AX    (AH-AL):累加器(所有I/O指令都通过AX与接口传送信息,中间运算结果烨多放于AX)</li>
<li>BX    (BH-BL):基址寄存器(在间接寻址中存放基地址)</li>
<li>CX    (CH-CL):计数寄存器(用于在循环或串操作指令中存放计数值)</li>
<li>DX    (DHDL):数据寄存器(在间接寻址中的I/O指令中存放I/O端口地址;在32位乘除法运算时,存放高16位数)</li>
</ul>
</li>
<li><p>地址指针寄存器</p>
<ul>
<li>SP    堆栈指针寄存器(内容为栈顶的偏移地址)</li>
<li>BP    基址指针寄存器(常用于在访问内存时存放内存单元的偏移地址)</li>
</ul>
<blockquote>
<p>当存在堆栈操作时,SP成为专用寄存器; BX（基址寄存器）表示所寻找的数据在<strong>数据段</strong>，BP（基址指针寄存器）表示数据在<strong>堆栈段</strong>． </p>
</blockquote>
</li>
<li><p>变址寄存器</p>
<ul>
<li>SI    源变址寄存器</li>
<li>DI    目的变址寄存器</li>
</ul>
<blockquote>
<p>变址寄存器在指令中常用于存放数据在内存中的地址</p>
</blockquote>
</li>
</ul>
</li>
<li><p>控制寄存器</p>
<ul>
<li>状态标志位1(对于16位数)<ul>
<li>CF（Carry Flag）</li>
<li>OF（Overflow Flag）</li>
<li>ZF（Zero Flag）</li>
<li>SF（Sign Flag）</li>
</ul>
</li>
<li>状态标志位2<ul>
<li>PF（Parity Flag）奇偶标志位运算结果的低8位中”1“的个数为偶数时PF=1；</li>
<li>AF   (Auxiliary Flag)    辅助进位标志位在加减操作中，若Bit3向Bit4有进位或借位，AF＝１；</li>
</ul>
</li>
<li>控制标志位<ul>
<li>TF（Trap Flag）陷阱标志位，也叫跟踪标志位。TF=1 时，使CPU处于单步执行指令的工作方式</li>
<li>IF（Interrupt Enable Flag）中断允许标志位。IF=1使CPU可以响应可屏蔽中断请求</li>
<li>DF（Direction Flag）方向标志位在数据串操作时确定操作的方向</li>
</ul>
</li>
</ul>
</li>
<li><p>段寄存器</p>
<p><code>作用</code></p>
<ul>
<li>存放相应2逻辑段的段基地址</li>
</ul>
<p><code>类型</code></p>
<ul>
<li>CS    代码段寄存器    存放代码段的段基地址</li>
<li>DS    数据段寄存器    存放数据段的段基地址</li>
<li>ES    附加段寄存器    存放数据段的段基地址</li>
<li>SS    堆栈段寄存器   存放堆栈段的段基地址</li>
</ul>
</li>
</ul>
<h3 id="实模型下的存储器寻址"><a href="#实模型下的存储器寻址" class="headerlink" title="实模型下的存储器寻址"></a>实模型下的存储器寻址</h3><p><code>概要</code></p>
<blockquote>
<p>8088是16位微处理器（生成63K个编码），需要管理1M内存空间保证每个内存单元在内存空间中具备唯一地址（物理地址）</p>
</blockquote>
<ul>
<li><p>内存单元编址</p>
<blockquote>
<p>内存中每个单元的地址在逻辑上都由两部分组成 </p>
</blockquote>
<ul>
<li>段（基）地址    <ul>
<li>指示存储单元在整个内存空间中处于哪个区域</li>
</ul>
</li>
<li>段内地址（相对地址/偏移地址）<ul>
<li>指示存储单元在段中的相对位置</li>
</ul>
</li>
</ul>
</li>
<li><p>实地址模式下的存储器地址变换</p>
</li>
</ul>
<p><code>段首地址</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527192150125.png" alt="image-20210527192150125"></p>
<p><code>物理地址</code></p>
<script type="math/tex; mode=display">
\\物理地址=段基地址*16+偏移地址\\</script><blockquote>
<p>段基地址和偏移地址都是16位；乘以16表示向左移位4</p>
</blockquote>
<ul>
<li><p>段寄存器</p>
<p><code>作用</code></p>
<ul>
<li>用于存放相应逻辑段的段基地址</li>
</ul>
<blockquote>
<p>8088内存中每类逻辑段的数量最多为64K个</p>
</blockquote>
</li>
<li><p>逻辑段与逻辑地址</p>
<ul>
<li>内存的分段是逻辑分段，不是物理分段各个逻辑段在地址上可以不相连、可以部分重合，也可以完全重合</li>
<li><strong>每个内存单元具有唯一地址，但可能具有多个逻辑地址</strong></li>
</ul>
</li>
<li><p>堆栈段以及堆栈段的使用</p>
<p><code>堆栈</code></p>
<ul>
<li>内存中一个特殊区域，用于存放暂时不用或需要保护的数据</li>
<li>常用于响应中断或子程序调用</li>
</ul>
<p><code>示例</code></p>
<blockquote>
<p>SS 段寄存器中的堆栈寄存器（存放堆栈段段基地址）    SP 通用寄存器 地址指针寄存器 （栈顶的偏移地址）</p>
</blockquote>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210527194815222.png" alt="image-20210527194815222"></p>
</li>
</ul>
<h3 id="8088总线结构"><a href="#8088总线结构" class="headerlink" title="8088总线结构"></a>8088总线结构</h3><ul>
<li><p>总线时序</p>
<ul>
<li><p>CPU工作时序</p>
<ul>
<li>CPU各引脚信号在时间上的关系</li>
</ul>
</li>
<li><p>总线周期</p>
<ul>
<li>CPU完成一次访问内存或接口操作所需要的时间</li>
<li>一个总线周期至少包括4各时钟周期</li>
</ul>
</li>
<li><p>8088最小模式下的工作时序</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528135717487.png" alt="image-20210528135717487"></p>
</li>
</ul>
</li>
<li><p>总线的概念</p>
<p><code>总线</code></p>
<p>​    是一组导线和相关的控制、驱动电路的集合是计算机系统个部件之间传输地址、数据和控制信息的通道</p>
<p><code>分类</code></p>
<script type="math/tex; mode=display">
按照层次结构划分
\begin{cases}
CPU总线 \\ \\
系统总线 \\\\
外部总线
\end{cases}</script></li>
<li><p>总线结构</p>
<ul>
<li><p>单总线结构</p>
</li>
<li><p>多总线结构</p>
<script type="math/tex; mode=display">
\begin{cases}
双总线结构
\begin{cases}
面向CPU的双总线结构 \\
面向主存的双总线结构
\end{cases}
 \hspace{-5cm}\\
多总线结构 \\
\end{cases}</script><p><code>面向CPU的双总线结构</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528140557644.png" alt="image-20210528140557644"></p>
<p><code>面向主存的双总线结构</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528140630715.png" alt="image-20210528140630715"></p>
</li>
</ul>
</li>
<li><p>总线的基本功能</p>
<script type="math/tex; mode=display">
\begin{cases}
数据传送

\begin{cases}
同步方式 \\ 
半同步（半异步） \\
异步方式
\end{cases}
\hspace{-2.5cm}\\
仲裁控制 \\
出错处理\\
总线驱动
\end{cases}</script></li>
<li><p>总线的主要性能指标</p>
<ul>
<li>总线带宽<ul>
<li>单位时间内总线上可传递的数据量</li>
</ul>
</li>
<li>总线位宽<ul>
<li>能同时传送的数据位数</li>
</ul>
</li>
<li>总线的工作频率<ul>
<li>总线带宽=（位宽/8）x （工作频率/每个存取周期的时钟树）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指令系统概述与数据传送指令"><a href="#指令系统概述与数据传送指令" class="headerlink" title="指令系统概述与数据传送指令"></a>指令系统概述与数据传送指令</h2><h3 id="指令系统基本概念"><a href="#指令系统基本概念" class="headerlink" title="指令系统基本概念"></a>指令系统基本概念</h3><ul>
<li><p>指令与指令系统</p>
<ul>
<li>指令：控制计算机完成某种操作的命令</li>
<li>指令系统：处理器所能识别的所有指令的集合</li>
<li>指令的兼容性：同一系列机的指令都是兼容的</li>
</ul>
</li>
<li><p>指令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作码		[操作数]	[操作数]</span><br><span class="line">执行的操作	目标		  源</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{cases}
零操作数 \\
单操作数 \\
双操作数指令\\
多操作数指令（三操作数以上，多用于大型机） \hspace{-7cm}\\
\end{cases}</script></li>
</ul>
<ul>
<li><p>指令中的操作数</p>
<script type="math/tex; mode=display">
\begin{cases}
立即数 \\
寄存器 \\
存储器
\end{cases}</script><blockquote>
<p>立即数只能作为<strong>源操作数</strong>；存储器操作数的表现形式：<strong>[</strong>偏移地址<strong>]</strong></p>
</blockquote>
</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><blockquote>
<p>寻找操作数所在地址的方式有指令直接给出、存放于寄存器、存放于存储器主要三种类型</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{cases}
指令直接给出的方式 \\
存放于寄存器中的寻址方式 \\
存放于存储器中的方式\\
隐含给出的方式
\end{cases}</script><ul>
<li><p>立即寻址</p>
</li>
<li><p>寄存器寻址</p>
</li>
<li><p>存储器操作数的寻址方式</p>
<blockquote>
<p>指令操作的对象在内存中，指令给出的是对象的内存某个逻辑段的偏移地址【偏移地址】；逻辑段的段基地址可以通过默认或<strong>重设方式</strong>给出</p>
<p>存储器操作数的字长本身不确定，其字长取决于指令中另一个寄存器操作数或通过其其他方式指定字长</p>
</blockquote>
<ul>
<li><p>直接寻址</p>
<ul>
<li>指令中直接给出操作数的偏移地址</li>
</ul>
<blockquote>
<p>直接寻址方式下，操作数默认在数据段，<strong>允许段重设</strong></p>
</blockquote>
</li>
<li><p>寄存器间接寻址</p>
<ul>
<li>操作数在内存中，数据在内存中的偏移地址为方括号中寄存器的内容</li>
</ul>
<blockquote>
<p>仅有4各通用寄存器可用于存放数据的偏移地址</p>
<p>【间址寄存器】 BX（通用寄存器—数据寄存器—基址寄存器）、BP、SI、DI(变址寄存器—源变址寄存器、目的变址寄存器)</p>
<p>BP默认数据在堆栈段</p>
</blockquote>
</li>
<li><p>寄存器相对寻址（主要用于一维数组的操作）</p>
<ul>
<li>操作数的偏移地址为寄存器的内容加上一个位移量</li>
</ul>
</li>
<li><p>基址、变址寻址（主要用于一维数组的操作）</p>
<ul>
<li><p>操作数的偏移地址为：一个基址寄存器的内容+一个变址寄存器的内容</p>
<blockquote>
<p>操作数的段地址由选择的基址寄存器决定；基址寄存器为BX，默认在数据段‘基址寄存器为BP，默认在堆栈段</p>
</blockquote>
</li>
</ul>
</li>
<li><p>基址、变址、相对寻址（主要用于二维表格的操作）</p>
<ul>
<li><p>操作数的偏移地址为：基址寄存器内容+ 变址寄存器内容+位移量</p>
<blockquote>
<p>操作数的段地址由选择的基地址寄存器决定</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>隐含寻址</p>
<ul>
<li>指令中隐含了一个或者两个操作数的地址，及操作数在默认的地址中。</li>
</ul>
</li>
</ul>
<p><code>练习</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528150655185.png" alt="image-20210528150655185"></p>
<h3 id="8086指令系统"><a href="#8086指令系统" class="headerlink" title="8086指令系统"></a>8086指令系统</h3><script type="math/tex; mode=display">
从功能上划分
\begin{cases}
数据传送 \\
算术运算 \\
逻辑运算和移位\\
串操作\\
程序控制\\
处理器控制
\end{cases}</script><ul>
<li><p>数据传送类指令</p>
<ul>
<li><p>通用数据传送指令（对标志位不产生影响）</p>
<ul>
<li>一般数据传送指令    <strong>MOV</strong> dest，src<script type="math/tex; mode=display">
注意点
\begin{cases}
两操作数字长必须相同 \\
两操作数不允许同时为存储器操作数 \\
两操作数不允许同时为段寄存器\\
源操作数为立即数时，目标操作数不能是段寄存器\\
IP和CS不作为目标操作数，很少用为源操作数
\end{cases}</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>FLAGS一般也不作为操作数在指令中出现</p>
</blockquote>
<ul>
<li><p>堆栈操作指令   </p>
<blockquote>
<p>先进先出、<strong>以字为单位</strong></p>
</blockquote>
<ul>
<li><p>压栈指令</p>
<ul>
<li><strong>PUSH</strong> OPRD（16位寄存器或存储器两单元）</li>
</ul>
</li>
<li><p>出栈指令</p>
<ul>
<li><strong>POP</strong> OPRD</li>
</ul>
<script type="math/tex; mode=display">
    堆栈操作指令说明
    \begin{cases}
    指令的操作数必须是一个字（16位） \\
    操作数不能是立即数 \\
    不能从栈顶弹出一个字给CS\\
    PUSH和POP指令在程序中一般成对出现\\
    PUSH指令的操作方向是从高地址向低地址\\
    \end{cases}</script></li>
</ul>
</li>
</ul>
<ul>
<li><p>交换指令    <strong>XCHG</strong> REG    MEM/REG</p>
<pre><code>$$
</code></pre><p>注意点</p>
<pre><code>\begin&#123;cases&#125;
两操作数必须有一个是寄存器操作数（既不能是内存与内存之间交换） \\
不允许使用段寄存器 \hspace&#123;9cm&#125;\\
\end&#123;cases&#125;
$$
</code></pre></li>
<li><p>查表转换指令    <strong>XLAT</strong></p>
<ul>
<li>隐含寻址：用BX的内容代表表格首地址，AL内容为表内位移量，BX+AL得到要查找的元素的偏移地址。将BX＋AL所指单元内容送AL。</li>
</ul>
</li>
<li><p>字位拓展指令  （分别分为有符号数拓展和无符号数拓展）</p>
<blockquote>
<p>将符号数的符号位拓展到高位;指令为零操作数指令,采用隐含寻址,操作数为AX以及AX，DX；</p>
</blockquote>
<ul>
<li>字节到字的拓展指令    <strong>CBW</strong><pre><code>+ 将AL内容拓展到AX
</code></pre><ul>
<li>字到双字的拓展指令    <strong>CWD</strong><ul>
<li>将AX内容拓展到DX AX；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>输入输出指令（对标志位不产生影响）</p>
<p><code>I/O端口</code>：I/O接口中用于存储数据</p>
<p><code>指令功能</code>：从端口地址读入数据到累加器/将累加器的值输出到端口中</p>
<p><code>指令格式</code><strong>IN</strong> acc,PORT             <strong>OUT</strong> PORT, acc</p>
<blockquote>
<p>acc为AX或AL；PORT为端口地址</p>
</blockquote>
<p><code>端口地址</code>：在I/O接口的系统下的寻址方式形成的地址。</p>
<blockquote>
<p>I/O 指令规定<strong>8位</strong>端口地址可以<strong>直接由指令给出</strong>（直接寻址，寻址256个端口）</p>
<p>端口地址为<strong>16位</strong>时，指令中的端口地址<strong>必须由DX指定</strong>（间接寻址，可寻址64K个端口）</p>
</blockquote>
</li>
<li><p>地址传送指令（对标志位不产生影响）</p>
<ul>
<li><p><strong>LEA</strong>    取近地址指令</p>
<p><code>操作</code>将<strong>变量</strong>(符号地址)的16位偏移地址写入到目标寄存器</p>
<blockquote>
<p>当程序中用符号表示内存偏移地址时,需使用须指令</p>
</blockquote>
<p><code>格式</code>LEA　REG，MEM</p>
<blockquote>
<p>源操作数必须是一个存储器操作数,目标操作数通常是间址寄存器</p>
</blockquote>
<p><code>示例</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528190016420.png" alt="image-20210528190016420"></p>
</li>
<li><p>LDS（Load　pointer　using　DS）</p>
<ul>
<li>LDS 通用寄存器,存ＥＳ储器操作数    段地址送入DS</li>
</ul>
</li>
<li><p>LES</p>
<ul>
<li>LES 通用寄存器,存储器操作数    段地址送入ES</li>
</ul>
<blockquote>
<p> LDS 和LES均用于将一个32位的远地址指针写入到目标寄存器.</p>
<p>其中16位段地址送入段寄存器,偏移地址送入目标寄存器</p>
</blockquote>
</li>
</ul>
</li>
<li><p>标志传送指令</p>
<ul>
<li><p>LAHF（Load AH from Flags）</p>
<ul>
<li><p>将FLAGS的低八位装入AH</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528190837130.png" alt="image-20210528190837130"></p>
</li>
</ul>
</li>
<li><p>SAHF（Store AH into Flags）</p>
</li>
<li><p>PUSHF（Push flags onto stack）</p>
</li>
<li><p>POPF（Pop flags off stack）</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对标志位不产生影响的指令，不能够跟基于某个标志位的状态来控制程序转移的指令（条件转移指令）</p>
</blockquote>
<h2 id="输入输出与中断技术"><a href="#输入输出与中断技术" class="headerlink" title="输入输出与中断技术"></a>输入输出与中断技术</h2><h3 id="I-O系统概述"><a href="#I-O系统概述" class="headerlink" title="I/O系统概述"></a>I/O系统概述</h3><ul>
<li><p>I/O接口</p>
<p><code>要解决的问题</code></p>
<script type="math/tex; mode=display">
堆栈操作指令说明
\begin{cases}
速度匹配——数据的缓冲与暂存 \\
信号的驱动能力——信号驱动 \\
信号形式和电平的匹配——信号类型转换\\
信息格式——信号格式转换\\
时序匹配（定时关系）\\
总线隔离——三态门
\end{cases}</script><p><code>接口的基本构成示意图</code></p>
</li>
</ul>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210528224714152.png" alt="image-20210528224714152"></p>
<ul>
<li><p>I/O端口以及编址</p>
<p><code>端口</code>：接口电路中用于缓存数据以及控制信息的部件</p>
<script type="math/tex; mode=display">
三种类型
\begin{cases}
数据端口 \\
状态端口 \\
控制端口
\end{cases}</script><p><code>编址</code></p>
</li>
</ul>
<blockquote>
<p>计算机系统中包含各类不同功能的接口电路；每个接口电路包含<strong>一个或多个端口</strong>；</p>
<p><strong>编址的目的</strong>是确保CPU能够访问到每个不同的端口</p>
</blockquote>
<p>​    <code>寻找端口的方法</code></p>
<ul>
<li>先找到端口所在的接口电路芯片——<strong>片选</strong><ul>
<li>再在该芯片上找到具体访问的端口——<strong>片内地址</strong></li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
  每个端口地址=片选地址（高位地址）+片内地址</script><ul>
<li><p>8088/8086的I/O端口编址</p>
<ul>
<li>采用I/O<strong>独立编址</strong>的方式，与内存公用地址总线，用IO$\overline{\text{M}}$信号状态区分</li>
<li>访问端口时仅使用总线地址总线的： A<sub>15</sub>~A<sub>0</sub></li>
<li>可寻址的I/O端口数为64K（65536）个，I/O地址范围：0~FFFFH</li>
<li>IBM　PC只使用了1024个I/O地址（0~3FFH）</li>
</ul>
</li>
<li><p>I/O地址译码</p>
<p><code>目的</code>：确定端口地址</p>
<p><code>参加译码的信号</code>：$\overline{\text{IOR}}$、$\overline{\text{IOW}}$、高位地址信号</p>
<p><code>对端口读/写信号的产生条件</code>：IO/$\overline{\text{M}}$=1；$\overline{\text{RD}}=0 $ $\overline{\text{IOR}}=0$；$\overline{\text{WR}}=0$ $\overline{\text{IOW}}=0$；</p>
<blockquote>
<p>OUT指令使总线的$\overline{\text{IOW}}$信号（总线控制器的引脚信号）有效；IN指令使总线的$\overline{\text{IOR}}$信号有效。</p>
</blockquote>
<ul>
<li>当接口只有一个端口时，无片内地址，全部地址信号均为高位地址，译码输出直接选择该端口</li>
<li>当接口有多个端口时，则16位地址线的高位参与译码，低位则用于确定具体的端口</li>
</ul>
<blockquote>
<p>由于端口资源丰富，端口地址译码常采用部分地址译码。</p>
</blockquote>
</li>
<li><p>I/O地址译码示例</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529093652450.png" alt="image-20210529093652450"><br><code>地址范围</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529093754723.png" alt="image-20210529093754723"></p>
<p><code>译码电路设计</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529093929874.png" alt="image-20210529093929874"></p>
<blockquote>
<p>与非门对应地址线中为1的地址线；或非门对应0的地址线。低位作为片内选址的输入。</p>
</blockquote>
</li>
</ul>
<h3 id="简单接口芯片"><a href="#简单接口芯片" class="headerlink" title="简单接口芯片"></a>简单接口芯片</h3><p><code>分类</code></p>
<script type="math/tex; mode=display">
传输信息方向分类
\begin{cases}
输入接口 \\
输出接口 \\
\end{cases}
\\
传输信息类型分类
\begin{cases}
数字接口 \\ 
模拟接口 \\
\end{cases}
\\
传输信息方式分类
\begin{cases}
并行接口 \\ 
串行接口 \\
\end{cases}
\\</script><h4 id="三态门接口"><a href="#三态门接口" class="headerlink" title="三态门接口"></a>三态门接口</h4><p><code>特点</code>：具有对数据的控制能力，但不具备对锁存能力</p>
<ul>
<li><p>74LS244</p>
<ul>
<li>含有8个三态门的集成电路芯片</li>
<li>在外设具有数据保持能力时用来作为输入接口</li>
</ul>
<p><code>引脚图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529095154476.png" alt="image-20210529095154476" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="锁存器接口"><a href="#锁存器接口" class="headerlink" title="锁存器接口"></a>锁存器接口</h4><p><code>特点</code>：具有对数据的锁存能力</p>
<ul>
<li><p>8D锁存器</p>
<ul>
<li>74LS273：8D触发器，不具备数据的控制能力</li>
<li>74LS373：含三态门的8D触发器，具有对数据的控制能力</li>
</ul>
</li>
<li><p>74LS273</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529100522401.png" alt="image-20210529100522401"></p>
</li>
</ul>
<h3 id="基本输入输出方法"><a href="#基本输入输出方法" class="headerlink" title="基本输入输出方法"></a>基本输入输出方法</h3><p><code>分类</code></p>
<script type="math/tex; mode=display">
\begin{cases}
无条件传送\\ 
查询方式传送 \\
中断方式传送\\
直接存储器存取（DMA）.\hspace{-3cm} \\
\end{cases}</script><blockquote>
<p>无条件传送和查询式传送都是程序控制方式</p>
</blockquote>
<ul>
<li><p>无条件传送</p>
<ul>
<li><p>要求外设总是处于准备好的状态</p>
<p><code>优点</code>：软件及接口硬件简单</p>
<p><code>缺点</code>：只适用于简单外设，适应范围窄</p>
</li>
</ul>
</li>
<li><p>查询工作方式</p>
<ul>
<li><p>仅当条件满足时才进行数据传送。<strong>每满足一次条件只能进行一次数据传送</strong>。</p>
<p><code>适用场合</code>：外设并不总是准备好；对传送速率和效率不高</p>
<p><code>工作条件</code>：外设能提供设备状态信息；接口应具备状态端口；</p>
<p><code>优点</code>：软硬件比较简单</p>
<p><code>缺点</code>：CPU效率低；数据传送时效性差；速度较慢。</p>
</li>
<li><p>流程图</p>
</li>
</ul>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529101437451.png" alt="image-20210529101437451" style="zoom: 50%;"></p>
</li>
<li><p>中断控制方式</p>
<ul>
<li><p>外设在需要时向CPU提出请求，CPU再去为它服务。</p>
<p><code>优点</code>：CPU效率高；实时性好；速度快；</p>
<p><code>缺点</code>：程序编制相对较为复杂</p>
</li>
</ul>
<p>以上三种I/O方式的共性：</p>
<blockquote>
<p>信息的传送需要CPU；</p>
<p><code>软件</code>：外设与内存之间的数据传送是通过CPU执行程序来完成的</p>
<p><code>硬件</code>：I/O接口和存储器的读写控制信号、地址信号都是由CPU发出</p>
<p><code>缺点</code>：程序的执行速度限定了传送的最大速度</p>
</blockquote>
</li>
<li><p>DMA控制方式</p>
<ul>
<li>外设直接与存储器进行数据交换；总线由<strong>DMA控制器</strong>（DMAC）进行控制，内存/外设的地址读写控制信号均有DMAC提供。</li>
</ul>
<p><code>示意图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529102315774.png" alt="image-20210529102315774"></p>
<ul>
<li><p>工作过程</p>
<ul>
<li>外设向DMAC发出“DMA传送请求”信号DRQ；</li>
<li>DMAC收到请求后，向CPU发出“总线请求”信号HOLD</li>
<li>CPU在完成当前总线周期后会立即发出HLDA，对HOLD响应</li>
<li>DMAC收到HLDA信号后，就开始控制总线，并向外设发出DMA响应信号DACK</li>
</ul>
</li>
<li><p>工作方式</p>
<ul>
<li><p>周期窃取(常用)</p>
<ul>
<li><p>每个DMA周期只传送一个字节或一个字就立即释放总线</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103435854.png" alt="image-20210529103435854"></p>
</li>
</ul>
</li>
<li><p>数据块传送</p>
<ul>
<li>DMAC在申请到总线后,将一块数据传送完才释放总线,而不管中间DREQ是否有效</li>
</ul>
</li>
<li><p>直接存取方式</p>
<ul>
<li>DMA的数据传送请求直接发送到主存储器，在得到响应后，整个工作过程在DMAC中由硬件完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简单I-O接口电路设计"><a href="#简单I-O接口电路设计" class="headerlink" title="简单I/O接口电路设计"></a>简单I/O接口电路设计</h3><p><code>题目</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103644330.png" alt="image-20210529103644330"></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103711101.png" alt="image-20210529103711101"></p>
<p><code>编码</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103742653.png" alt="image-20210529103742653"></p>
<p><code>电路</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103813128.png" alt="image-20210529103813128"></p>
<p><code>程序段</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529103838796.png" alt="image-20210529103838796"></p>
<h3 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h3><p><code>中断基本该概念</code>：CPU执行程序时，由于发生了某种随机的事件（中断源），引起CPU暂时中断正在运行 的程序，转去执行一段特殊的服务程序（中断服务处理子程序），以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断。</p>
<p><code>引入中断的原因</code>：提高对外设请求的响应实时性；提高了CPU的利用率，无需一直检测外设的状态。</p>
<p><code>中断类型</code></p>
<ul>
<li>内部中断<ul>
<li>异常中断——异常事件引起</li>
<li>软件中断——中断指令引起 </li>
</ul>
</li>
<li>外部中断<ul>
<li>可屏蔽中断——INTR中断</li>
<li>非屏蔽中断——NMI中断</li>
</ul>
</li>
</ul>
<p><code>外部可屏蔽中断响应的一般过程</code></p>
<ol>
<li>中断请求</li>
<li>中断源识别以及中断判优</li>
<li>中断响应</li>
<li>中断处理（服务）</li>
<li>中断返回</li>
</ol>
<ul>
<li><p>中断请求（外部可屏蔽中断信号）</p>
<ul>
<li>中断请求信号应保持到中断被处理为止，CPU响应中断后，中断请求信号应即使撤销</li>
</ul>
</li>
<li><p>中断源识别</p>
<p><code>中断源识别</code></p>
<ul>
<li>软件查询法</li>
<li>中断矢量法——由中断源提供中断类型号，CPU根据类型确定中断源</li>
</ul>
<p><code>中断判优</code></p>
<ul>
<li>优先级法则</li>
<li>排队法则</li>
</ul>
</li>
<li><p>中断源判优</p>
<ul>
<li><p>中断控制器判优：根据<strong>中断向量码（中断类型码）</strong>确定中断源</p>
<p><code>中断控制器8259A</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529110853987.png" alt="image-20210529110853987"></p>
</li>
</ul>
</li>
<li><p>中断响应（外部可屏蔽中断响应信号$\overline{\text{INTA}}$）</p>
<ul>
<li>向中断源发出$\overline{\text{INTA}}$中断响应信号</li>
<li>关中断——不允许响应其他中断</li>
<li>保护硬件现场——将FLAGS压入堆栈</li>
<li>保护断点——将CS、IP压入堆栈</li>
<li>获得中断服务程序入口</li>
</ul>
</li>
<li><p>中断处理</p>
<ul>
<li><p>执行中断服务子程序</p>
<p><code>中断服务子程序的特点</code>：远过程；用IRET指令返回</p>
<p><code>中断服务子程序完成的工作</code></p>
<ul>
<li>关中断，保护现场，保护断点，找入口地址</li>
<li>保护软件现场（参数）</li>
<li>开中断</li>
<li>中断处理</li>
<li>关中断</li>
<li>恢复现场</li>
<li>中断返回</li>
</ul>
</li>
</ul>
</li>
<li><p>中断返回</p>
<ul>
<li>执行IRET指令，使IP、CS和FLAGS从堆栈中弹出（恢复断点和硬件现场）</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529111643172.png" alt="image-20210529111643172"></p>
<p><code>中断向量表</code></p>
<blockquote>
<p>存放各类中断的中断服务程序的入口地址</p>
<p>位于内存00000H~003FFH</p>
</blockquote>
<ul>
<li>每个入口占用4Byte，低字段为段内偏移，高字段为段基地址；</li>
<li>终端向量表大小为1KB，共256个入口。</li>
</ul>
<p><code>8088内部中断与NMI中断</code></p>
<blockquote>
<p>无$\overline{\text{INTA}}$周期</p>
<p>中断类型码固定或者由指令给出</p>
</blockquote>
<p><code>8086/8088中断系统</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529112125845.png" alt="image-20210529112125845"></p>
<h2 id="可编程数字接口电路"><a href="#可编程数字接口电路" class="headerlink" title="可编程数字接口电路"></a>可编程数字接口电路</h2><h3 id="可编程定时器8253（非通道型）"><a href="#可编程定时器8253（非通道型）" class="headerlink" title="可编程定时器8253（非通道型）"></a>可编程定时器8253（非通道型）</h3><p><code>可编程</code>：可以通过软件命令控制芯片的工作方式（<strong>数据传输方式、输入/输出方式</strong>）</p>
<p><code>计数和定时</code>：以时钟脉冲为工作基准</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529123240703.png" alt="image-20210529123240703"></p>
<blockquote>
<p>计数脉冲周期恒定。计数初值根据计数量求出计数周期（即需要多少个脉冲）</p>
</blockquote>
<ul>
<li>8253芯片特点<ul>
<li>可编程的逻辑器件</li>
<li>非通道型的接口，具有特色功能（体现为对外设的控制）</li>
<li>可实现计数和定时</li>
<li>工作方式<ul>
<li>减法计数</li>
<li>计数值为0进行OUT</li>
<li>输出控制信号的形式可以通过软件设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>外部引线及内部结构</code></p>
<ul>
<li><p>引线</p>
<p><code>连接系统的主要引线</code></p>
<ul>
<li>D<sub>0</sub>~D<sub>7</sub></li>
<li>$\overline{\text{CS}}$</li>
<li>$\overline{\text{RD}}$</li>
<li>$\overline{\text{WR}}$</li>
<li>A<sub>0</sub> 、A<sub>1</sub></li>
</ul>
<p><code>连接外设端的主要引线</code></p>
<ul>
<li>CLK——时钟脉冲输入</li>
<li><strong>GATE</strong>——门控信号输入</li>
<li>OUT——定时输出</li>
</ul>
<p><code>引脚图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529124048097.png" alt="image-20210529124048097" style="zoom: 80%;"></p>
</li>
<li><p>内部结构特点</p>
<blockquote>
<p>具有三个完全相独立的计数/定时器</p>
</blockquote>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529124220720.png" alt="image-20210529124220720"></p>
<ul>
<li><p>3个计数器均为减法计数器</p>
</li>
<li><p>每个计数器含16位初值寄存器、16位计数寄存器（<strong>公用一个端口地址</strong>）</p>
<blockquote>
<p>写入端口地址时，两个寄存器同时写入相同的内容</p>
</blockquote>
</li>
<li><p>控制寄存器——存放控制命令字</p>
</li>
</ul>
<blockquote>
<p>共占用4个端口地址</p>
</blockquote>
<p><code>端口地址编码</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529124613133.png" alt="image-20210529124613133" style="zoom: 80%;"></p>
</li>
<li><p>计数启动方式</p>
<blockquote>
<p>启动方式由GATE端信号的形式决定</p>
</blockquote>
<ul>
<li>软件启动——GATE为高电平</li>
<li>硬件启动——GATE为上升沿</li>
</ul>
</li>
<li><p>工作方式</p>
<ul>
<li><p>方式0</p>
<ul>
<li><strong>软件启动，不自动重复计数</strong></li>
<li>计数结束输出高电平</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529125045113.png" alt="image-20210529125045113"></p>
</li>
<li><p>方式1</p>
<ul>
<li>硬件启动，不自动重复计数</li>
<li>计数开始输出低电平，结束时变高</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529125146790.png" alt="image-20210529125146790"></p>
<blockquote>
<p>计数一旦启动，GATE端即使变低也不影响计数；<strong>可重复触发</strong>。</p>
</blockquote>
</li>
<li><p>方式2</p>
<ul>
<li>软、硬启动，自动重复计数</li>
<li>计数到最后一个脉冲时输出低电平</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529125404907.png" alt="image-20210529125404907"></p>
<blockquote>
<p>可输出频率为（1/N）CLK脉冲频率的连续方波</p>
<p>每个OUT端脉冲包括（N-1）<em>CLK的正脉冲</em>，1CLK的负脉冲</p>
</blockquote>
</li>
<li><p>方式3</p>
<ul>
<li>软、硬启动，自动重复计数</li>
<li>输出对称方波（计数初值为偶数）</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529125655997.png" alt="image-20210529125655997"></p>
<blockquote>
<p>若N为偶数，输出频率为（1/N）CLK频率的连续对称方波信号</p>
<p>若N为奇数，输出波形为（N+1）/2CLK周期正脉冲，（N-1）/2CLK周期负脉冲</p>
</blockquote>
</li>
<li><p>方式4</p>
<ul>
<li>软件启动，不自动重复计数</li>
<li>计数结束输出一个CLK宽度的低电平</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529130017951.png" alt="image-20210529130017951"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>方式5</p>
<ul>
<li>硬件启动，不自动重复计数</li>
<li>波形与方式4相同</li>
</ul>
<p><code>时序图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529130036378.png" alt="image-20210529130036378"></p>
<p><code>小结</code></p>
<blockquote>
<p>需要两个写脉冲——两次写操作（写入控制字、写入计数初值）</p>
<p>不同的工作方式有不同的计数启动方法和输出波形</p>
<p><strong>能输出连续波形的只有方式2和方式3</strong></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>控制字</p>
<p><code>作用</code>：用于设定各计数器的工作方式</p>
<p><code>格式</code>：8位</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529130501194.png" alt="image-20210529130501194" style="zoom:80%;"></p>
<blockquote>
<p>最大16位BCD数：9999</p>
<p>最大16位二进制数：FFFF</p>
<p>8253计数器最大计数初值：0（减法计数器）</p>
</blockquote>
</li>
<li><p>8253的应用</p>
<p><code>硬件设计</code>：与系统的连接</p>
<p><code>软件设计</code>：初始化程序设计</p>
<ul>
<li><p>与系统的连接示意图</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529140916449.png" alt="image-20210529140916449"></p>
</li>
<li><p>应用中的注意点</p>
<ul>
<li>每次启动计数，需两次写操作（控制字，计数初值）</li>
<li>计数器的控制命令字送入控制寄存器</li>
<li>各计数器的计数初值送到该计数器寄存器及初值寄存器</li>
</ul>
</li>
<li><p>初始化流程</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529141141749.png" alt="image-20210529141141749"></p>
<blockquote>
<p>多个计数器初始化时的原则：<strong>先写入控制字，后写入计数初值</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>应用案例</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529141324489.png" alt="image-20210529141324489"></p>
<p><code>相关内容</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529141424999.png" alt="image-20210529141424999"></p>
<p><code>硬连示意图</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529141500605.png" alt="image-20210529141500605"></p>
<p><code>初始化程序</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529141535021.png" alt="image-20210529141535021"></p>
</li>
</ul>
<h3 id="可编程并行接口8255（通道型）"><a href="#可编程并行接口8255（通道型）" class="headerlink" title="可编程并行接口8255（通道型）"></a>可编程并行接口8255（通道型）</h3><blockquote>
<p>通道型接口：主要用于数据的输入和输出</p>
</blockquote>
<ul>
<li><p>8255特点</p>
<ul>
<li>通道型接口</li>
<li>含有3各独立的8位并行输入/输出端口<ul>
<li>2个位8位端口（PA，PB）</li>
<li>1个可拆分为两个4为端口（PC）</li>
</ul>
</li>
<li>各端口均具有数据的控制和锁存能力<ul>
<li>既可以作为输入端口，也可以作为输出端口</li>
</ul>
</li>
<li>可通过编程，设置各端口工作在某一确定状态</li>
</ul>
</li>
<li><p>结构</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529142540745.png" alt="image-20210529142540745"></p>
<blockquote>
<p>A组控制 A端口和C口高４位；B组控制B端口和C口低四位</p>
</blockquote>
</li>
<li><p>引线</p>
<p>`连接系统的主要引引脚</p>
<ul>
<li>D<sub>0</sub>~D<sub>7</sub></li>
<li>$\overline{\text{CS}}$</li>
<li>$\overline{\text{RD}}$</li>
<li>$\overline{\text{WR}}$</li>
<li>A<sub>0</sub>、A<sub>1</sub></li>
<li>RESET</li>
</ul>
<p><code>连接外设端的主要引脚</code></p>
<ul>
<li>PA<sub>0</sub>~PA<sub>7PB</sub></li>
<li>PB<sub>0</sub>~PB<sub>7</sub></li>
<li>PC<sub>0</sub>~PC<sub>7</sub></li>
</ul>
</li>
<li><p>8256与系统连接示意图</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529143225900.png" alt="image-20210529143225900"></p>
</li>
<li><p>工作方式</p>
<script type="math/tex; mode=display">
\begin{cases}
基本输入/输出方式（方式0） \\ \\
选通工作方式（方式1）\\ \\
双向传递方式（方式2） 
\end{cases}</script></li>
<li><p>方式0</p>
<ul>
<li>相当于3各独立的8位简单接口</li>
<li>各端既可以设置为输入口，也可以设置为输出口，但不能同时实现输入以及输出</li>
<li>常用于连接简单外设，<strong>适用于无条件或查询方式</strong></li>
</ul>
<p><code>应用</code></p>
<ul>
<li>习惯上A端口和B端口作为８数据的输入或输出口</li>
<li>C口的某些位作为状态输入</li>
</ul>
<blockquote>
<p>若C端口低四位某一位作为输入,则低四位中其他位都应作为输入口.同时高四位可设为输出口.</p>
</blockquote>
</li>
<li><p>方式1</p>
<ul>
<li>利用一组选通控制信号控制A端口和B端口的数据输入输出．</li>
<li>A口、B口作输入或输出口，<strong>C口的部分位用作选通控制信号</strong></li>
<li>A口、V口在作为输入、输出时的选通信号不同</li>
</ul>
<p><code>方式1 选通信号和输出波形</code><strong>作为输出</strong></p>
<p><code>选通信号</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150131166.png" alt="image-20210529150131166"></p>
<p><code>输出方式</code>：CPU= =&gt;PA= =&gt;外设</p>
<p><code>工作时序</code></p>
<ul>
<li>CPU 在一个写周期把数据写入A端口——IOW信号，使OBF有效</li>
<li>A端口通知外设——OBF</li>
<li>外设接收到信息，将接口中数据取出——外设发出应答信号ACK ACK结束会使INTR产生高电平</li>
<li>A端口通知CPU可以继续传送数据</li>
</ul>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150209378.png" alt="image-20210529150209378" style="zoom:80%;"></p>
<p><code>方式1 选通信号和输出波形</code><strong>作为输入</strong></p>
<p><code>输出方式</code>：CPU&lt;= =PA&lt;= =外设</p>
<p><code>选通信号</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150241008.png" alt="image-20210529150241008"></p>
<p><code>工作时序</code></p>
<ul>
<li>$\overline{\text{STB }}$有效期间，外设将数据写入PA,同时端口产生IBF信号作为与外设的应答信号</li>
<li>$\overline{\text{STB }}$无效时,触发INTR中断请求信号,通知CPU取数据</li>
<li>CPU产生IOR信号,读取接口数据</li>
<li>读取完毕,使IBF失效</li>
</ul>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150300644.png" alt="image-20210529150300644"></p>
<p><code>方式1应用</code></p>
<ul>
<li>主要用于中断控制方式下的输入输出</li>
<li><strong>C口的8位除用作选通信号外,其余位可工作于方式0下,作为输入或输出口</strong></li>
</ul>
</li>
<li><p>方式2</p>
<ul>
<li>双向输入输出方式<ul>
<li>既可以作为输入口,又作为输出口</li>
</ul>
</li>
<li>只有A端可工作在方式2下</li>
</ul>
<p><code>选通信号</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150713274.png" alt="image-20210529150713274" style="zoom:50%;"></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529150743789.png" alt="image-20210529150743789" style="zoom: 50%;"></p>
<p><code>方式2的应用</code></p>
<ul>
<li>可使A端口作为双向端口所有</li>
<li>用于中断控制方式</li>
<li>当A口工作于方式2时：<ul>
<li>B口可工作于方式1<ul>
<li>此时C口的所有位都用做选通控制信号的输入输出</li>
</ul>
</li>
<li>B口也可工作与方式0<ul>
<li>此时C口的剩余位也可工作于方式0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方式控制字及位控制字 </p>
<ul>
<li>方式控制字<ul>
<li>用于确定3个端口的工作方式及数据传输的方向</li>
</ul>
</li>
<li>位控制字<ul>
<li><strong>仅用于C端口</strong></li>
<li>可设置C口某位的初始状态（一般工作在方式0并且作为输出时 用来初始化）</li>
</ul>
</li>
</ul>
</li>
<li><p>8255控制字</p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529152114933.png" alt="image-20210529152114933"></p>
<blockquote>
<p>方式控制字1——4——3    指明方式控制1-（A组方式选择、A口方向、C接口高４位方向）－（B组方式选择、B口方向、C接口低４位方向）</p>
<p>0输出，1输入</p>
</blockquote>
</li>
</ul>
<p><code>小节</code></p>
<blockquote>
<p>方式1通过方式控制字确定端口的传输方向；方式2只需要根据脉冲改变传输方向</p>
<p>只能PA单独工作于方式２　需要PC中多达５位选通信号</p>
</blockquote>
<ul>
<li>8255芯片的应用</li>
</ul>
<p><code>案例</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529154102913.png" alt="image-20210529154102913"></p>
<p><code>地址范围</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529154123358.png" alt="image-20210529154123358"></p>
<p><code>控制流程</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529154149841.png" alt="image-20210529154149841"></p>
<p><code>控制程序</code></p>
<p><img src="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/image-20210529160040056.png" alt="image-20210529160040056"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/">http://example.com/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/05/14/realme/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">zhy</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">微处理器与总线结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8088-8086-CPU"><span class="toc-number">1.1.</span> <span class="toc-text">8088&#x2F;8086 CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8088%E4%B8%BB%E8%A6%81%E5%BC%95%E8%84%9A%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.1.</span> <span class="toc-text">8088主要引脚信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8088%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">8088内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8088%E5%86%85%E9%83%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">8088内部寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text">实模型下的存储器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8088%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">8088总线结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">指令系统概述与数据传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">指令系统基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">8086指令系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">输入输出与中断技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">I&#x2F;O系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87"><span class="toc-number">3.2.</span> <span class="toc-text">简单接口芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%80%81%E9%97%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">三态门接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AD%98%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">锁存器接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">基本输入输出方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95I-O%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">简单I&#x2F;O接口电路设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">中断技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%95%B0%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">可编程数字接口电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A88253%EF%BC%88%E9%9D%9E%E9%80%9A%E9%81%93%E5%9E%8B%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">可编程定时器8253（非通道型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%B9%B6%E8%A1%8C%E6%8E%A5%E5%8F%A38255%EF%BC%88%E9%80%9A%E9%81%93%E5%9E%8B%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">可编程并行接口8255（通道型）</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/" title="微机原理与接口技术"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微机原理与接口技术"/></a><div class="content"><a class="title" href="/2021/05/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/" title="微机原理与接口技术">微机原理与接口技术</a><time datetime="2021-05-27T05:16:47.713Z" title="Created 2021-05-27 13:16:47">2021-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/realme/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/05/14/realme/" title="No title">No title</a><time datetime="2021-05-14T06:34:55.924Z" title="Created 2021-05-14 14:34:55">2021-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/11/Android-Studio%E7%AC%94%E8%AE%B0/" title="Android Studio笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android Studio笔记"/></a><div class="content"><a class="title" href="/2021/05/11/Android-Studio%E7%AC%94%E8%AE%B0/" title="Android Studio笔记">Android Studio笔记</a><time datetime="2021-05-11T12:48:32.000Z" title="Created 2021-05-11 20:48:32">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/25/Untitled%201/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/04/25/Untitled%201/" title="No title">No title</a><time datetime="2021-04-25T06:03:21.301Z" title="Created 2021-04-25 14:03:21">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机系统结构"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机系统结构"/></a><div class="content"><a class="title" href="/2021/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机系统结构">计算机系统结构</a><time datetime="2021-04-21T12:27:59.000Z" title="Created 2021-04-21 20:27:59">2021-04-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By zhy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>